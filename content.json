{"meta":{"title":"Miracle","subtitle":null,"description":"改变从每天开始。","author":"cmemory","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"golang-sort","slug":"golang-sort","date":"2020-10-24T07:57:59.000Z","updated":"2020-10-24T18:09:02.290Z","comments":true,"path":"2020/10/24/golang-sort/","link":"","permalink":"http://yoursite.com/2020/10/24/golang-sort/","excerpt":"","text":"排序整体介绍golang提供了sort接口，我们可以只要实现该接口就可以调用内置的Sort函数进行排序。 12345678910111213// 集合类型需要实现该接口才能直接使用Sort函数type Interface interface &#123; Len() int // 集合长度 Less(i, j int) bool // 集合中i位置的元素是否应该排在j位置元素的前面 Swap(i, j int) // 交换集合i和j位置的元素&#125;// Sort函数，直接调用的quickSort进行处理func Sort(data Interface) &#123; n := data.Len() // maxDepth 快排递归的深度，每次递归都会减1，当减为0时采用堆排序。 quickSort(data, 0, n, maxDepth(n))&#125; golang整个Sort的实现使用了快速排序、堆排序、希尔排序、插入排序。 1、整体流程上使用的是递归的快速排序。（元素大于12时）2、初始时会根据集合元素的个数计算一个max_depth，为递归的最大深度。3、每次递归的时候max_depth会减一，当递归到该值为0时，采用堆排序。4、当元素&lt;=12时，排序采用步长为6的希尔排序。这里只需要一遍希尔就可以了。5、对于希尔排序结果，采用插入排序完成最终排序。 排序代码流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 对于长度为n的集合，max_depth为2*ceil(lg(n+1))，lg(n+1)向上取整的两倍。// 快排复杂度为O(lgn)，这里是给出最大递归深度max_depth，超过后要切换为堆排序。func maxDepth(n int) int &#123; var depth int for i := n; i &gt; 0; i &gt;&gt;= 1 &#123; depth++ &#125; return depth * 2&#125;// Sort中调用的此函数进行排序func quickSort(data Interface, a, b, maxDepth int) &#123; for b-a &gt; 12 &#123; // maxDepth 降为0时采用堆排序 if maxDepth == 0 &#123; heapSort(data, a, b) return &#125; maxDepth-- // doPivot寻找合适的切分元素pivot，将集合数据划分为3部分，并返回两个切分点mlo, mhi。 // [a,mlo)的元素都小于pivot // [mhi,b)的元素都大于pivot // [mlo,mhi)之间的元素都等于pivot mlo, mhi := doPivot(data, a, b) // 对于元素少的那一部分进行递归调用。元素多的部分使用尾递归。减少递归栈内存使用。 if mlo-a &lt; b-mhi &#123; quickSort(data, a, mlo, maxDepth) a = mhi // 尾递归优化，等价于quickSort(data, mhi, b, maxDepth) &#125; else &#123; quickSort(data, mhi, b, maxDepth) b = mlo // 等价于quickSort(data, a, mlo, maxDepth) &#125; &#125; // 递归过程中元素个数不超过12时，采用一次希尔排序加一次插入排序 if b-a &gt; 1 &#123; // 元素不超过12，所以步长为6，每次只需要比对两个元素。 for i := a + 6; i &lt; b; i++ &#123; if data.Less(i, i-6) &#123; data.Swap(i, i-6) &#125; &#125; // 插入排序，使得最终集合有序 insertionSort(data, a, b) &#125;&#125;// 插入和希尔排序这里很清楚了，就不另外解释了。func insertionSort(data Interface, a, b int) &#123; for i := a + 1; i &lt; b; i++ &#123; // 对于所选择的元素i，依次向前对比，如果i更小，则交换。 for j := i; j &gt; a &amp;&amp; data.Less(j, j-1); j-- &#123; data.Swap(j, j-1) &#125; &#125;&#125; 快速排序Sort中快速排序思路就是两步：1、划分。选取一个基准元素，将集合划分为&lt;，=，&gt;基准元素的三个新集合。2、递归。将得到的三个新的集合递归进行处理。 可以看到，真正处理部分是在划分，而划分的难点实际上在于每次基准元素的选择。如果基准元素选择的不好，极端情况快排退化成了插入排序，如每次都选取到最小元素的情况。理论上最优的基准元素是中位数，大于和小于基准元素的个数基本相等。 Sort中快排基准点选择使用的是基于采样的median of three medians of three方式。1、对于集合开始、中间、末尾分别采样3个元素。2、分别求采样的三个部分各自中位数，得到3个数。3、求这3个数的中位数，即作为基准元素进行一次的划分。 从上面我们可以知道，对于选择的基准点p，集合中至少有3+1个元素&gt;=p，且至少有3+1个元素&lt;=p。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// 排序3个元素使得data[m0] &lt;= data[m1] &lt;= data[m2]，从而我们知道m1处的元素即为中位数。func medianOfThree(data Interface, m1, m0, m2 int) &#123; if data.Less(m1, m0) &#123; data.Swap(m1, m0) &#125; if data.Less(m2, m1) &#123; data.Swap(m2, m1) if data.Less(m1, m0) &#123; data.Swap(m1, m0) &#125; &#125;&#125;func doPivot(data Interface, lo, hi int) (midlo, midhi int) &#123; m := int(uint(lo+hi) &gt;&gt; 1) // 避免int溢出 if hi-lo &gt; 40 &#123; s := (hi - lo) / 8 // 选择采样步长 // 在头、中、尾分别采样，计算相应的中位数放置在lo、m、hi-1位置 medianOfThree(data, lo, lo+s, lo+2*s) medianOfThree(data, m, m-s, m+s) medianOfThree(data, hi-1, hi-1-s, hi-1-2*s) &#125; // 取lo、m、hi-1位置的数，计算中位数放在首位 medianOfThree(data, lo, m, hi-1) ----------------------------------------------------------------- // 不变式: // 1、data[lo] = pivot (选择的基准) // 2、data[lo &lt; i &lt; a] &lt; pivot (由下面第一个for循环保证) // 3、data[a &lt;= i &lt; b] &lt;= pivot // 4、data[b &lt;= i &lt; c] unexamined // 5、data[c &lt;= i &lt; hi-1] &gt; pivot // 6、data[hi-1] &gt;= pivot (有前面中位数选择保证) pivot := lo a, c := lo+1, hi-1 // 不变式的2由这个循环保证 for ; a &lt; c &amp;&amp; data.Less(a, pivot); a++ &#123; &#125; b := a // 不变式的3、4、5由这个循环保证，将剩下元素划分为&lt;=和&gt;两个部分。 for &#123; for ; b &lt; c &amp;&amp; !data.Less(pivot, b); b++ &#123; // data[b] &lt;= pivot &#125; for ; b &lt; c &amp;&amp; data.Less(pivot, c-1); c-- &#123; // data[c-1] &gt; pivot &#125; if b &gt;= c &#123; break &#125; // data[b] &gt; pivot; data[c-1] &lt;= pivot // 交换并缩减比较范围 data.Swap(b, c-1) b++ c-- &#125; // 经过前面的操作，得到如下划分：(这里应该有b==c) // 1、data[lo] = pivot // 2、data[lo &lt; i &lt; a] &lt; pivot // 3、data[a &lt;= i &lt; b] &lt;= pivot // 4、data[c &lt;= i &lt; hi-1] &gt; pivot // 5、data[hi-1] &gt;= pivot (有前面中位数选择保证) // 后面要做的是尽可能将与基准相等的元素放在[b,c)，保证尽可能少的元素再参与递归处理。 // 事实上，相同的元素不做处理也是可以的，只是如果相同元素过多会影响性能。 ---------------------------------------------------------------- // 前面说过，集合中至少有4个元素&gt;=基准，不算基准有3个&gt;=基准 // 所以当hi-c &lt; 3的时候，集合中前面一定有等于基准的元素。 // 这里比较保守，边界设置的5。小于5就认为需要检查。 protect := hi-c &lt; 5 if !protect &amp;&amp; hi-c &lt; (hi-lo)/4 &#123; // 当[c, hi)的元素个数&gt;=5且&lt;总元素个数的1/4时 // 选取一些点测试是否与基准相等 dups := 0 // 检测hi-1处元素，因为没有equals函数，所以只能这样检查。 if !data.Less(pivot, hi-1) &#123; // data[hi-1] &lt;= pivot data.Swap(c, hi-1) c++ dups++ &#125; // 检测b-1处元素是否与基准相等，如果相等则b==c-1，不等则b==c if !data.Less(b-1, pivot) &#123; // data[b-1] &gt;= pivot b-- dups++ &#125; // m-lo = (hi-lo)/2 // 由if条件可知：hi-c &lt; (hi-lo)/4 ==&gt; c-lo&gt;(hi-lo)3/4 // 又因为b&lt;=c，事实上b==c或者b==c-1，则b-lo&gt;(hi-lo)3/4-1 // ==&gt; b-lo &gt; m-lo // ==&gt; m &lt; b ==&gt; data[m] &lt;= pivot if !data.Less(m, pivot) &#123; // data[m] = pivot data.Swap(m, b-1) b-- dups++ &#125; // 如果三个检测点中至少有两个点都与基准相等，则假定偏态分布 // 前面可能还有很多与基准相等的点，需要进行遍历检测处理。 protect = dups &gt; 1 &#125; if protect &#123; // 检查与基准相同元素，根据我们前面划分，只需要判断[a,b)的元素就可以了。 // 处理过程跟前面划分集合为&lt;=和&gt;两部分类似。 // 循环不变式: // data[a &lt;= i &lt; b] 待检测 // data[b &lt;= i &lt; c] = pivot for &#123; // 循环，遇到与基准相等的，b--，继续检查 for ; a &lt; b &amp;&amp; !data.Less(b-1, pivot); b-- &#123; // data[b] == pivot &#125; for ; a &lt; b &amp;&amp; data.Less(a, pivot); a++ &#123; // data[a] &lt; pivot &#125; if a &gt;= b &#123; break &#125; // data[a] == pivot; data[b-1] &lt; pivot data.Swap(a, b-1) a++ b-- &#125; &#125; // 将基准放到合适的位置，最终[lo, b-1)都小于基准。[c，hi)都大于基准。 data.Swap(pivot, b-1) return b - 1, c 堆排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func heapSort(data Interface, a, b int) &#123; first := a lo := 0 hi := b - a // 构建大根堆，需要依次遍历节点，调整以节点为根的树成为大根堆。 // 由于调整当前节点时，必须保证子树都已经是大根堆，所以这里从后往前遍历。 // 显然叶子节点只有单个节点，就是一个大根堆，不需要处理。 for i := (hi - 1) / 2; i &gt;= 0; i-- &#123; siftDown(data, i, hi, first) &#125; // 每次取最大（堆顶）元素与堆末尾元素交换。然后调整堆使重新成为大根堆。 // 每次操作，堆中元素会少一个，而有序的元素会加一。 // 最终会形成一个从小到大排好序的序列。 for i := hi - 1; i &gt;= 0; i-- &#123; data.Swap(first, first+i) siftDown(data, lo, i, first) &#125;&#125;// siftDown，节点lo依次向下比较，使得以lo为根的树是一个大根堆。// 注意调整lo为根的树时，必须保证lo的子树都已经是大根堆。// 这里由于集合元素是[0, hi)，所以判断是否有子节点使用2*root+1&gt;=hi。func siftDown(data Interface, lo, hi, first int) &#123; root := lo for &#123; child := 2*root + 1 // 判断是否有子节点，没有则直接跳出循环返回。 if child &gt;= hi &#123; break &#125; // 先比较两个孩子节点，child最终指向大的那个孩子。 // 默认child是指向左孩子的，如果没有右孩子，child仍然是指向大的那个孩子。 if child+1 &lt; hi &amp;&amp; data.Less(first+child, first+child+1) &#123; child++ &#125; // 对比较大的孩子与当前节点，如果当前节点大，则不用变动就是大根，直接返回 if !data.Less(first+root, first+child) &#123; return &#125; // 孩子节点大于当前节点，则需要交换。 // 交换后破坏了所交换孩子的那颗子树，需要重新调整为大根堆。 data.Swap(first+root, first+child) root = child &#125;&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"}]},{"title":"基本数据结构","slug":"基本数据结构","date":"2019-02-22T02:44:29.000Z","updated":"2020-10-24T07:44:46.167Z","comments":true,"path":"2019/02/22/基本数据结构/","link":"","permalink":"http://yoursite.com/2019/02/22/基本数据结构/","excerpt":"","text":"这里主要定义了基本的结点，并简要的实现了队列和栈用于后续使用。 节点定义单链表节点1234type LNode struct &#123; T interface&#123;&#125; Next *LNode&#125; 二叉树节点12345type BNode struct &#123; T interface&#123;&#125; Left *BNode Right *BNode&#125; 队列简要实现123456789101112131415161718192021222324252627282930313233343536373839404142434445// 队列类型定义type Queue struct &#123; head *LNode tail *LNode len int&#125;func NewQueue() *Queue&#123; return &amp;Queue&#123;nil,nil,0&#125;&#125;func (q *Queue) QLen() int&#123; return q.len&#125;func (q *Queue) IsEmpty() bool&#123; return q.len == 0&#125;// 这里采用pop头 push尾的方式。这样pop删除操作更好处理。func (q *Queue) Push(val interface&#123;&#125;)&#123; node := &amp;LNode&#123;val,nil&#125; if q.len == 0 &#123; q.head = node &#125;else &#123; q.tail.Next = node &#125; q.tail = node q.len ++&#125;func (q *Queue) pop() (interface&#123;&#125;,bool)&#123; if q.len == 0 &#123; fmt.Println(\"queue is empty!\") return nil,false &#125; tmp := q.head q.head = tmp.Next tmp.Next = nil q.len -- if q.head == nil &#123; q.tail = nil &#125; return tmp.T,true&#125; 栈简要实现123456789101112131415161718192021222324252627282930313233343536373839404142// 栈的定义，head头设为栈顶，这样处理pop更好处理type Stack struct &#123; head *LNode len int&#125;func NewStack() *Stack&#123; return &amp;Stack&#123;nil,0&#125;&#125;func (s *Stack) SLen() int&#123; return s.len&#125;func (s *Stack) IsEmpty() bool&#123; return s.len == 0&#125;func (s *Stack) Push(val interface&#123;&#125;) &#123; s.head = &amp;LNode&#123;val,s.head&#125; s.len ++&#125;func (s *Stack) Pop() (interface&#123;&#125;,bool)&#123; if s.len == 0 &#123; fmt.Println(\"stack is empty!\") return nil,false &#125; tmp := s.head s.head = tmp.Next tmp.Next = nil s.len -- return tmp.T,true&#125;func (s *Stack) Top() (interface&#123;&#125;,bool)&#123; if s.len == 0 &#123; fmt.Println(\"stack is empty!\") return nil,false &#125; return s.head.T,true&#125;","categories":[],"tags":[]},{"title":"二叉树的遍历（一）","slug":"二叉树的遍历（一）","date":"2019-02-22T02:39:04.000Z","updated":"2020-10-24T07:44:46.162Z","comments":true,"path":"2019/02/22/二叉树的遍历（一）/","link":"","permalink":"http://yoursite.com/2019/02/22/二叉树的遍历（一）/","excerpt":"","text":"&emsp;&emsp;一个二叉树，要么为空，要么是由一个根节点（N）及其左右两棵子二叉树（L/R）构成。因而，非空二叉树分为三个部分，按照这种递归分析可得到3!=6种遍历方式。我们一般只分析先序（NLR）、中序（LNR）、后序（LRN）三种方式，另外三种实际上是这三种的逆序。 二叉树的生成&emsp;&emsp;这段仅仅是为了后面有一个二叉树可用，可自行跳过直接看下一节。&emsp;&emsp;给定一个二叉树的先序序列字符串 AB##CD##EF##G#H## ，构建一个二叉树，其中#为nil（空指针）。可以按照定义去处理，首先构建根结点，再递归的构建左子树和右子树。由于只有一个字符串，我们无法直接知道划分点，但可以肯定的是根字符一定在左子树字符之前，左子树字符一定在右子树字符之前。基于此我们可以在构建树的时候同时返回下一个字符来解决。 二叉树的定义123type BTree struct &#123; root *datastructure.BNode&#125; 先序递归构建二叉树1234567891011121314func Create(str string, i int, len int) (*datastructure.BNode, int) &#123; // 当遍历到字符串结尾或者当前字符为#时，返回 if i &gt; len-1 || str[i] == '#'&#123; return nil,i+1 &#125; left,index := Create(str,i+1,len) // 递归构建左子树 right,index := Create(str,index,len) // 递归构建右子树 return &amp;datastructure.BNode&#123;T:str[i],Left:left,Right:right&#125;,index //返回二叉树的根节点及下一个字符index&#125;func CreateBTree(str string) *BTree&#123; node,_ := Create(str,0,len(str)) return &amp;BTree&#123;node&#125;&#125; 先序遍历递归方式&emsp;&emsp;先序（NLR），即先根、然后左子树、最后右子树。左右子树又是单独的一个二叉树的遍历。按照这种递归的思路，我们很容易写出递归代码。123456789func (bt *BTree) PreOrder() &#123; if bt.root == nil &#123; return &#125; fmt.Printf(\"%c\", bt.root.T) // 为了将Node封装成Tree，使得这里显得很蠢 (&amp;BTree&#123;bt.root.Left&#125;).PreOrder() (&amp;BTree&#123;bt.root.Right&#125;).PreOrder()&#125; 非递归方式&emsp;&emsp;前面的递归方式实际上借助了一个系统函数调用栈实现的，如果要改为非递归，可以使用显式栈来实现。我们知道二叉树中每个结点有左右两棵子树，当到达某个结点时，如果选择左子树遍历，则后面必定会再一次返回该结点，从而去访问右子树。因此每个结点都需要经过两次。我们可以选择是在第一次或者第二次经过时处理结点，这两种选择分别对应于二叉树遍历的先序和中序方式。 思路一：&emsp;&emsp;每次处理某个结点时，先将右孩子压栈，再将左孩子压栈，这样可以保证当前节点优先于孩子节点处理，左孩子由于右孩子处理。 1. 首先将根节点入栈。 2. 循环只要栈不空，则pop一个节点处理。 3. 该节点右孩子不为空，则入栈。 4. 该几点左孩子不为空，则入栈。 12345678910111213141516171819202122232425262728293031func (bt *BTree) PreOrder1() &#123; if bt.root == nil &#123; return &#125; s := datastructure.NewStack() s.Push(bt.root) p := bt.root for !s.IsEmpty() &#123; t, _ := s.Pop() p = t.(*datastructure.BNode) fmt.Printf(\"%c\",p.T) if p.Right != nil &#123; s.Push(p.Right) &#125; if p.Left != nil&#123; s.Push(p.Left) &#125; // 下面代码是对上面整个循环体内代码的一个优化，减少栈的push pop操作。类似于尾递归的优化。 // fmt.Printf(\"%c\",p.T) // if p.Right != nil &#123; // s.Push(p.Right) // &#125; // if p.Left != nil&#123; // p = p.Left // &#125;else &#123; // t, _ := s.Pop() // p = t.(*datastructure.BNode) // &#125; &#125; fmt.Println()&#125; 思路二：&emsp;&emsp;从根节点一直向左按顺序访问并入栈，直到没有左孩子。然后弹出一个节点，访问该节点的右子树（仍然重复前面动作，即从根向左找）。由访问顺序可知，总是先访问了根节点再访问左子树，直到无左子树或已被访问，才转而访问右子树，故符合先序。 1. 从根节点开始，结点非空时处理当前结点并入栈。 2. 当左孩子非空时，一直向左孩子处理并入栈。 3. 当左孩子为空时，弹出结点，处理结点的右子树（即回到1） 4. 循环处理，直到栈为空退出。 123456789101112131415161718192021func (bt *BTree) PreOrder2() &#123; if bt.root == nil &#123; return &#125; p := bt.root s := datastructure.NewStack() for p!=nil || !s.IsEmpty() &#123; // 代码简化： // 将根节点的处理合并进了左孩子的情况。 // 利用if-else和外层的for循环替换掉了内层向左孩子查询的循环。 if p!=nil &#123; s.Push(p) fmt.Printf(\"%c\",p.T) p = p.Left &#125;else&#123; t,_ := s.Pop() p = t.(*datastructure.BNode).Right &#125; &#125; fmt.Println()&#125; 中序遍历递归方式&emsp;&emsp;类似于前面先序方式。但中序遍历是先处理左子树，接着处理根节点，最后处理右子树。12345678func (bt *BTree) InOrder() &#123; if bt.root == nil &#123; return &#125; (&amp;BTree&#123;bt.root.Left&#125;).InOrder() fmt.Printf(\"%c\",bt.root.T) (&amp;BTree&#123;bt.root.Right&#125;).InOrder()&#125; 非递归方式&emsp;&emsp;之前有介绍利用栈遍历时，结点会经过两次，中序遍历是在第二次经过时处理结点，因为此时它的左子树都访问完了，而又准备访问右子树，故符合中序。 思路一：&emsp;&emsp;同先序遍历的思路二，只是处理结点由push处改为pop处。12345678910111213141516171819func (bt *BTree) InOrder1() &#123; if bt.root == nil &#123; return &#125; p := bt.root s := datastructure.NewStack() for p!=nil || !s.IsEmpty() &#123; if p!=nil &#123; s.Push(p) p = p.Left &#125;else&#123; t,_ := s.Pop() p = t.(*datastructure.BNode) fmt.Printf(\"%c\",p.T) p = p.Right &#125; &#125; fmt.Println()&#125; 后序遍历递归方式&emsp;&emsp;思想同前。处理时先遍历左子树，接着遍历右子树，最后处理根结点。12345678func (bt *BTree) PostOrder() &#123; if bt.root == nil &#123; return &#125; (&amp;BTree&#123;bt.root.Left&#125;).PostOrder() (&amp;BTree&#123;bt.root.Right&#125;).PostOrder() fmt.Printf(\"%c\",bt.root.T)&#125; 非递归方式&emsp;&emsp;由于需要多次经过结点，同样需要借助辅助栈的方式处理。按照在之前分析的，对于某个结点，先序在第一次经过时处理，中序在第二次经过时处理，而后序如果要处理该结点则处理完右边后还要再退回经过该节点处理才行，即需要三次经过该结点。我们知道栈push与pop分别对应两个状态，故处理先序、中序足够了。现在后序需要三种状态，所以要么另外再加一个标识实现第三种状态，要么就转化为先序或中序的思路进行处理，这样就有了两大思路方向了。 思路一：&emsp;&emsp;加一个标识达到第三种状态。这样在第一次经过时入栈，第二次经过时暂不做处理，只有当经过该结点且达到相应状态时才处理该结点。可以对每个结点进行一层封装，增加一个标识字段，这样某个结点需要达到状态为孩子为空或孩子均已被访问。也可以只用一个last字段指向上一个处理的字段，当（左右孩子均为空）或（右孩子不为空且last为右孩子）或（右孩子不为空且左孩子不为空且last为左孩子）时达到状态，处理当前节点。显然前者更复杂，且空间开销更大，此处我们选择后一种方法。 1. 由于是后序遍历，首先处理的节点是最左边节点，故先向左扫描并将途中结点入栈。直到向左所有节点都入栈。 2. 只要栈非空，就取栈顶结点，判断该结点是否满足状态。 3. 满足状态，则处理该节点，并弹出。 4. 不满足状态，此时我们一定是第二次经过该结点（第一次是入栈，第三次是满足状态）， 由之前中序遍历分析知道，结点左子树已经访问完了，故我们只需要移步到它的右孩子节点，然后重复1步骤就好。 （或者可以在步骤2中直接弹出节点，3中只处理，4中不满足再push进去。但前面的显然更优。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768func (bt *BTree) PostOrder1()&#123; if bt.root == nil &#123; return &#125; cur := bt.root last := bt.root s := datastructure.NewStack() for cur!=nil || !s.IsEmpty() &#123; for cur!=nil &#123; s.Push(cur) cur = cur.Left &#125; t,_ := s.Top() cur = t.(*datastructure.BNode) // (cur.Left==nil&amp;&amp;cur.Right==nil)||(cur.Right!=nil&amp;&amp;last==cur.Right)||(cur.Right==nil&amp;&amp;cur.Left!=nil&amp;&amp;last==cur.Left) // 1、当循环开始cur!=nil时，由前面for cur!=nil循环可知，最终栈顶cur的Left必为nil。 // 所以第一个条件等价于cur.Right==nil ，第三个条件总为false // --&gt; cur.Right==nil || (cur.Right!=nil&amp;&amp;last==cur.Right) // --&gt; 看成 A || (~A &amp;&amp; B),利用集合公式化简为 (A || ~A)&amp;&amp;(A||B) --&gt; A||B // 也可这样分析：当前一个条件为true时 整个为true，当前一个为false时，后一个等价于last==cur.Right // --&gt; cur.Right==nil || last==cur.Right // 2、当循环开始cur==nil时，需要取栈顶元素作为cur，由之前分析可知左子树访问完了且右边未访问。 // 显然(cur.Left==nil||(cur.Left!=nil&amp;&amp;last==cur.Left))为true // 若cur.Left==nil，分析同1. // 若cur.Left!=nil&amp;&amp;last==cur.Left，第一个条件为false，第二个条件也为false，第三个条件等价于cur.Right==nil // // 综上：最终条件为 cur.Right==nil || last==cur.Right // 前面条件表达式实际上有几处是可以利用&amp;&amp;和||的短路特性进行简化的，简化之后再来讨论相应会简单很多。 if cur.Right==nil || last==cur.Right&#123; s.Pop() fmt.Printf(\"%c\",cur.T) last = cur cur = nil &#125;else&#123; cur = cur.Right &#125; &#125; fmt.Println()&#125;func (bt *BTree) Post()&#123; if bt.root == nil &#123; return &#125; s := datastructure.NewStack() cur := bt.root var last *datastructure.BNode = nil s.Push(cur) for !s.IsEmpty()&#123; t,_ := s.Top() cur = t.(*datastructure.BNode) if last == nil || last.Left == cur || last.Right == cur &#123; if cur.Left!=nil &#123; s.Push(cur.Left) &#125;else if cur.Right!=nil &#123; s.Push(cur.Right) &#125; &#125;else if cur.Left == last&#123; if cur.Right!=nil &#123; s.Push(cur.Right) &#125; &#125;else &#123; fmt.Printf(\"%c\",cur.T) s.Pop() &#125; last = cur &#125;&#125; 思路二：&emsp;&emsp;后序遍历，即先左子树、再右子树、最后处理根结点，LRN方式。我们将之逆转，得到NRL，那么按照NRL方式遍历，得到的序列逆序不就是后序遍历序列么（这里我采用新增一个栈来处理逆序，当然也可以用其他方式）。进一步，需要解决的就是按照NRL方式遍历，细看一下，这不就是先序遍历的翻版么。只需将先序遍历所有left与right指针对调，处理的地方换成压到另一个栈操作即可。 1. 按NRL方式遍历，按处理序列依次入out栈 2. 再依次从out弹出处理 12345678910111213141516171819202122232425// 所有适用于先序遍历的实现，同样适用于此思路的后序遍历。// 这里只取先序遍历思路二的方法来实现后序遍历。func (bt *BTree) PostOrder2()&#123; if bt.root == nil &#123; return &#125; p := bt.root tmpS := datastructure.NewStack() outS := datastructure.NewStack() for p != nil || !tmpS.IsEmpty() &#123; if p != nil &#123; tmpS.Push(p) outS.Push(p) p = p.Right &#125;else&#123; t,_ := tmpS.Pop() p = t.(*datastructure.BNode).Left &#125; &#125; for !outS.IsEmpty() &#123; p,_ := outS.Pop() fmt.Printf(\"%c\",p.(*datastructure.BNode).T) &#125; fmt.Println()&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-01-03T14:37:18.216Z","updated":"2019-01-03T14:37:18.216Z","comments":true,"path":"2019/01/03/hello-world/","link":"","permalink":"http://yoursite.com/2019/01/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}