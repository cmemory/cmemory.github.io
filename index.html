<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="改变从每天开始。">
<meta property="og:type" content="website">
<meta property="og:title" content="Miracle">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Miracle">
<meta property="og:description" content="改变从每天开始。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Miracle">
<meta name="twitter:description" content="改变从每天开始。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title> Miracle </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Miracle</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/24/golang-sort/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmemory">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Miracle">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/10/24/golang-sort/" itemprop="url">
                  golang-sort
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-24T15:57:59+08:00">
                2020-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="排序整体介绍"><a href="#排序整体介绍" class="headerlink" title="排序整体介绍"></a>排序整体介绍</h3><p>golang提供了sort接口，我们可以只要实现该接口就可以调用内置的Sort函数进行排序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合类型需要实现该接口才能直接使用Sort函数</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Len() <span class="keyword">int</span>	<span class="comment">// 集合长度</span></span><br><span class="line">	Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span>	<span class="comment">// 集合中i位置的元素是否应该排在j位置元素的前面</span></span><br><span class="line">	Swap(i, j <span class="keyword">int</span>)	<span class="comment">// 交换集合i和j位置的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort函数，直接调用的quickSort进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> &#123;</span><br><span class="line">	n := data.Len()</span><br><span class="line">    <span class="comment">// maxDepth 快排递归的深度，每次递归都会减1，当减为0时采用堆排序。</span></span><br><span class="line">	quickSort(data, <span class="number">0</span>, n, maxDepth(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>golang整个Sort的实现使用了快速排序、堆排序、希尔排序、插入排序。</p>
<p>1、整体流程上使用的是递归的快速排序。（元素大于12时）<br>2、初始时会根据集合元素的个数计算一个max_depth，为递归的最大深度。<br>3、每次递归的时候max_depth会减一，当递归到该值为0时，采用堆排序。<br>4、当元素&lt;=12时，排序采用步长为6的希尔排序。这里只需要一遍希尔就可以了。<br>5、对于希尔排序结果，采用插入排序完成最终排序。</p>
<h3 id="排序代码流程"><a href="#排序代码流程" class="headerlink" title="排序代码流程"></a>排序代码流程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于长度为n的集合，max_depth为2*ceil(lg(n+1))，lg(n+1)向上取整的两倍。</span></span><br><span class="line"><span class="comment">// 快排复杂度为O(lgn)，这里是给出最大递归深度max_depth，超过后要切换为堆排序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> depth <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := n; i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span> &#123;</span><br><span class="line">		depth++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> depth * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort中调用的此函数进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(data Interface, a, b, maxDepth <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> b-a &gt; <span class="number">12</span> &#123;</span><br><span class="line">        <span class="comment">// maxDepth 降为0时采用堆排序</span></span><br><span class="line">		<span class="keyword">if</span> maxDepth == <span class="number">0</span> &#123;</span><br><span class="line">			heapSort(data, a, b)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		maxDepth--</span><br><span class="line">        <span class="comment">// doPivot寻找合适的切分元素pivot，将集合数据划分为3部分，并返回两个切分点mlo, mhi。</span></span><br><span class="line">        <span class="comment">// [a,mlo)的元素都小于pivot</span></span><br><span class="line">        <span class="comment">// [mhi,b)的元素都大于pivot</span></span><br><span class="line">        <span class="comment">// [mlo,mhi)之间的元素都等于pivot</span></span><br><span class="line">		mlo, mhi := doPivot(data, a, b)</span><br><span class="line">        <span class="comment">// 对于元素少的那一部分进行递归调用。元素多的部分使用尾递归。减少递归栈内存使用。</span></span><br><span class="line">		<span class="keyword">if</span> mlo-a &lt; b-mhi &#123;</span><br><span class="line">			quickSort(data, a, mlo, maxDepth)</span><br><span class="line">			a = mhi <span class="comment">// 尾递归优化，等价于quickSort(data, mhi, b, maxDepth)</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			quickSort(data, mhi, b, maxDepth)</span><br><span class="line">			b = mlo <span class="comment">// 等价于quickSort(data, a, mlo, maxDepth)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归过程中元素个数不超过12时，采用一次希尔排序加一次插入排序</span></span><br><span class="line">	<span class="keyword">if</span> b-a &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 元素不超过12，所以步长为6，每次只需要比对两个元素。</span></span><br><span class="line">		<span class="keyword">for</span> i := a + <span class="number">6</span>; i &lt; b; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> data.Less(i, i<span class="number">-6</span>) &#123;</span><br><span class="line">				data.Swap(i, i<span class="number">-6</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 插入排序，使得最终集合有序</span></span><br><span class="line">		insertionSort(data, a, b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入和希尔排序这里很清楚了，就不另外解释了。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(data Interface, a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := a + <span class="number">1</span>; i &lt; b; i++ &#123;</span><br><span class="line">        <span class="comment">// 对于所选择的元素i，依次向前对比，如果i更小，则交换。</span></span><br><span class="line">		<span class="keyword">for</span> j := i; j &gt; a &amp;&amp; data.Less(j, j<span class="number">-1</span>); j-- &#123;</span><br><span class="line">			data.Swap(j, j<span class="number">-1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>Sort中快速排序思路就是两步：<br>1、划分。选取一个基准元素，将集合划分为&lt;，=，&gt;基准元素的三个新集合。<br>2、递归。将得到的三个新的集合递归进行处理。</p>
<p>可以看到，真正处理部分是在划分，而划分的难点实际上在于每次基准元素的选择。<br>如果基准元素选择的不好，极端情况快排退化成了插入排序，如每次都选取到最小元素的情况。<br>理论上最优的基准元素是中位数，大于和小于基准元素的个数基本相等。</p>
<p>Sort中快排基准点选择使用的是基于采样的<a href="https://www.johndcook.com/blog/2009/06/23/tukey-median-ninther/" target="_blank" rel="noopener">median of three medians of three</a>方式。<br>1、对于集合开始、中间、末尾分别采样3个元素。<br>2、分别求采样的三个部分各自中位数，得到3个数。<br>3、求这3个数的中位数，即作为基准元素进行一次的划分。</p>
<p>从上面我们可以知道，对于选择的基准点p，集合中至少有3+1个元素&gt;=p，且至少有3+1个元素&lt;=p。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序3个元素使得data[m0] &lt;= data[m1] &lt;= data[m2]，从而我们知道m1处的元素即为中位数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">medianOfThree</span><span class="params">(data Interface, m1, m0, m2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> data.Less(m1, m0) &#123;</span><br><span class="line">		data.Swap(m1, m0)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> data.Less(m2, m1) &#123;</span><br><span class="line">		data.Swap(m2, m1)</span><br><span class="line">		<span class="keyword">if</span> data.Less(m1, m0) &#123;</span><br><span class="line">			data.Swap(m1, m0)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doPivot</span><span class="params">(data Interface, lo, hi <span class="keyword">int</span>)</span> <span class="params">(midlo, midhi <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">int</span>(<span class="keyword">uint</span>(lo+hi) &gt;&gt; <span class="number">1</span>)	<span class="comment">// 避免int溢出</span></span><br><span class="line">	<span class="keyword">if</span> hi-lo &gt; <span class="number">40</span> &#123;</span><br><span class="line">		s := (hi - lo) / <span class="number">8</span>	<span class="comment">// 选择采样步长</span></span><br><span class="line">        <span class="comment">// 在头、中、尾分别采样，计算相应的中位数放置在lo、m、hi-1位置</span></span><br><span class="line">		medianOfThree(data, lo, lo+s, lo+<span class="number">2</span>*s)</span><br><span class="line">		medianOfThree(data, m, m-s, m+s)</span><br><span class="line">		medianOfThree(data, hi<span class="number">-1</span>, hi<span class="number">-1</span>-s, hi<span class="number">-1</span><span class="number">-2</span>*s)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 取lo、m、hi-1位置的数，计算中位数放在首位</span></span><br><span class="line">	medianOfThree(data, lo, m, hi<span class="number">-1</span>)</span><br><span class="line">    -----------------------------------------------------------------</span><br><span class="line">	<span class="comment">// 不变式:</span></span><br><span class="line">	<span class="comment">// 1、data[lo] = pivot (选择的基准)</span></span><br><span class="line">	<span class="comment">// 2、data[lo &lt; i &lt; a] &lt; pivot (由下面第一个for循环保证)</span></span><br><span class="line">	<span class="comment">// 3、data[a &lt;= i &lt; b] &lt;= pivot </span></span><br><span class="line">	<span class="comment">// 4、data[b &lt;= i &lt; c] unexamined</span></span><br><span class="line">	<span class="comment">// 5、data[c &lt;= i &lt; hi-1] &gt; pivot</span></span><br><span class="line">	<span class="comment">// 6、data[hi-1] &gt;= pivot (有前面中位数选择保证)</span></span><br><span class="line">	pivot := lo</span><br><span class="line">	a, c := lo+<span class="number">1</span>, hi<span class="number">-1</span></span><br><span class="line">	<span class="comment">// 不变式的2由这个循环保证</span></span><br><span class="line">	<span class="keyword">for</span> ; a &lt; c &amp;&amp; data.Less(a, pivot); a++ &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	b := a</span><br><span class="line">    <span class="comment">// 不变式的3、4、5由这个循环保证，将剩下元素划分为&lt;=和&gt;两个部分。</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> ; b &lt; c &amp;&amp; !data.Less(pivot, b); b++ &#123; <span class="comment">// data[b] &lt;= pivot</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ; b &lt; c &amp;&amp; data.Less(pivot, c<span class="number">-1</span>); c-- &#123; <span class="comment">// data[c-1] &gt; pivot</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> b &gt;= c &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// data[b] &gt; pivot; data[c-1] &lt;= pivot</span></span><br><span class="line">        <span class="comment">// 交换并缩减比较范围</span></span><br><span class="line">		data.Swap(b, c<span class="number">-1</span>)</span><br><span class="line">		b++</span><br><span class="line">		c--</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 经过前面的操作，得到如下划分：(这里应该有b==c)</span></span><br><span class="line">    <span class="comment">// 1、data[lo] = pivot</span></span><br><span class="line">    <span class="comment">// 2、data[lo &lt; i &lt; a] &lt; pivot</span></span><br><span class="line">    <span class="comment">// 3、data[a &lt;= i &lt; b] &lt;= pivot </span></span><br><span class="line">    <span class="comment">// 4、data[c &lt;= i &lt; hi-1] &gt; pivot</span></span><br><span class="line">    <span class="comment">// 5、data[hi-1] &gt;= pivot (有前面中位数选择保证)</span></span><br><span class="line">    <span class="comment">// 后面要做的是尽可能将与基准相等的元素放在[b,c)，保证尽可能少的元素再参与递归处理。</span></span><br><span class="line">    <span class="comment">// 事实上，相同的元素不做处理也是可以的，只是如果相同元素过多会影响性能。</span></span><br><span class="line">    ----------------------------------------------------------------</span><br><span class="line">    <span class="comment">// 前面说过，集合中至少有4个元素&gt;=基准，不算基准有3个&gt;=基准</span></span><br><span class="line">    <span class="comment">// 所以当hi-c &lt; 3的时候，集合中前面一定有等于基准的元素。</span></span><br><span class="line">    <span class="comment">// 这里比较保守，边界设置的5。小于5就认为需要检查。</span></span><br><span class="line">	protect := hi-c &lt; <span class="number">5</span></span><br><span class="line">	<span class="keyword">if</span> !protect &amp;&amp; hi-c &lt; (hi-lo)/<span class="number">4</span> &#123;</span><br><span class="line">        <span class="comment">// 当[c, hi)的元素个数&gt;=5且&lt;总元素个数的1/4时</span></span><br><span class="line">        <span class="comment">// 选取一些点测试是否与基准相等</span></span><br><span class="line">		dups := <span class="number">0</span></span><br><span class="line">        <span class="comment">// 检测hi-1处元素，因为没有equals函数，所以只能这样检查。</span></span><br><span class="line">		<span class="keyword">if</span> !data.Less(pivot, hi<span class="number">-1</span>) &#123; <span class="comment">// data[hi-1] &lt;= pivot</span></span><br><span class="line">			data.Swap(c, hi<span class="number">-1</span>)</span><br><span class="line">			c++</span><br><span class="line">			dups++</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 检测b-1处元素是否与基准相等，如果相等则b==c-1，不等则b==c</span></span><br><span class="line">		<span class="keyword">if</span> !data.Less(b<span class="number">-1</span>, pivot) &#123; <span class="comment">// data[b-1] &gt;= pivot</span></span><br><span class="line">			b--</span><br><span class="line">			dups++</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// m-lo = (hi-lo)/2</span></span><br><span class="line">        <span class="comment">// 由if条件可知：hi-c &lt; (hi-lo)/4 ==&gt; c-lo&gt;(hi-lo)3/4</span></span><br><span class="line">        <span class="comment">// 又因为b&lt;=c，事实上b==c或者b==c-1，则b-lo&gt;(hi-lo)3/4-1</span></span><br><span class="line">        <span class="comment">// ==&gt; b-lo &gt; m-lo</span></span><br><span class="line">		<span class="comment">// ==&gt; m &lt; b ==&gt; data[m] &lt;= pivot</span></span><br><span class="line">		<span class="keyword">if</span> !data.Less(m, pivot) &#123; <span class="comment">// data[m] = pivot</span></span><br><span class="line">			data.Swap(m, b<span class="number">-1</span>)</span><br><span class="line">			b--</span><br><span class="line">			dups++</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果三个检测点中至少有两个点都与基准相等，则假定偏态分布</span></span><br><span class="line">        <span class="comment">// 前面可能还有很多与基准相等的点，需要进行遍历检测处理。</span></span><br><span class="line">		protect = dups &gt; <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> protect &#123;</span><br><span class="line">        <span class="comment">// 检查与基准相同元素，根据我们前面划分，只需要判断[a,b)的元素就可以了。</span></span><br><span class="line">        <span class="comment">// 处理过程跟前面划分集合为&lt;=和&gt;两部分类似。</span></span><br><span class="line">		<span class="comment">// 循环不变式:</span></span><br><span class="line">		<span class="comment">//	data[a &lt;= i &lt; b] 待检测</span></span><br><span class="line">		<span class="comment">//	data[b &lt;= i &lt; c] = pivot</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 循环，遇到与基准相等的，b--，继续检查</span></span><br><span class="line">			<span class="keyword">for</span> ; a &lt; b &amp;&amp; !data.Less(b<span class="number">-1</span>, pivot); b-- &#123; <span class="comment">// data[b] == pivot</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> ; a &lt; b &amp;&amp; data.Less(a, pivot); a++ &#123; <span class="comment">// data[a] &lt; pivot</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// data[a] == pivot; data[b-1] &lt; pivot</span></span><br><span class="line">			data.Swap(a, b<span class="number">-1</span>)</span><br><span class="line">			a++</span><br><span class="line">			b--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 将基准放到合适的位置，最终[lo, b-1)都小于基准。[c，hi)都大于基准。</span></span><br><span class="line">	data.Swap(pivot, b<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> b - <span class="number">1</span>, c</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(data Interface, a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	first := a</span><br><span class="line">	lo := <span class="number">0</span></span><br><span class="line">	hi := b - a</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建大根堆，需要依次遍历节点，调整以节点为根的树成为大根堆。</span></span><br><span class="line">    <span class="comment">// 由于调整当前节点时，必须保证子树都已经是大根堆，所以这里从后往前遍历。</span></span><br><span class="line">    <span class="comment">// 显然叶子节点只有单个节点，就是一个大根堆，不需要处理。</span></span><br><span class="line">	<span class="keyword">for</span> i := (hi - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		siftDown(data, i, hi, first)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次取最大（堆顶）元素与堆末尾元素交换。然后调整堆使重新成为大根堆。</span></span><br><span class="line">    <span class="comment">// 每次操作，堆中元素会少一个，而有序的元素会加一。</span></span><br><span class="line">    <span class="comment">// 最终会形成一个从小到大排好序的序列。</span></span><br><span class="line">	<span class="keyword">for</span> i := hi - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		data.Swap(first, first+i)</span><br><span class="line">		siftDown(data, lo, i, first)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// siftDown，节点lo依次向下比较，使得以lo为根的树是一个大根堆。</span></span><br><span class="line"><span class="comment">// 注意调整lo为根的树时，必须保证lo的子树都已经是大根堆。</span></span><br><span class="line"><span class="comment">// 这里由于集合元素是[0, hi)，所以判断是否有子节点使用2*root+1&gt;=hi。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown</span><span class="params">(data Interface, lo, hi, first <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	root := lo</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		child := <span class="number">2</span>*root + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 判断是否有子节点，没有则直接跳出循环返回。</span></span><br><span class="line">		<span class="keyword">if</span> child &gt;= hi &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 先比较两个孩子节点，child最终指向大的那个孩子。</span></span><br><span class="line">        <span class="comment">// 默认child是指向左孩子的，如果没有右孩子，child仍然是指向大的那个孩子。</span></span><br><span class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; hi &amp;&amp; data.Less(first+child, first+child+<span class="number">1</span>) &#123;</span><br><span class="line">			child++</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 对比较大的孩子与当前节点，如果当前节点大，则不用变动就是大根，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> !data.Less(first+root, first+child) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 孩子节点大于当前节点，则需要交换。</span></span><br><span class="line">        <span class="comment">// 交换后破坏了所交换孩子的那颗子树，需要重新调整为大根堆。</span></span><br><span class="line">		data.Swap(first+root, first+child)</span><br><span class="line">		root = child</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/22/基本数据结构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmemory">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Miracle">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/22/基本数据结构/" itemprop="url">
                  基本数据结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-22T10:44:29+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里主要定义了基本的结点，并简要的实现了队列和栈用于后续使用。</p>
<h2 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h2><h3 id="单链表节点"><a href="#单链表节点" class="headerlink" title="单链表节点"></a>单链表节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    T <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    Next *LNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树节点"><a href="#二叉树节点" class="headerlink" title="二叉树节点"></a>二叉树节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    T <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    Left *BNode</span><br><span class="line">    Right *BNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列简要实现"><a href="#队列简要实现" class="headerlink" title="队列简要实现"></a>队列简要实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列类型定义</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">    head *LNode</span><br><span class="line">    tail *LNode</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">()</span> *<span class="title">Queue</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Queue&#123;<span class="literal">nil</span>,<span class="literal">nil</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">QLen</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q.<span class="built_in">len</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q.<span class="built_in">len</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里采用pop头 push尾的方式。这样pop删除操作更好处理。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    node := &amp;LNode&#123;val,<span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> q.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        q.head = node</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        q.tail.Next = node</span><br><span class="line">    &#125;</span><br><span class="line">    q.tail = node</span><br><span class="line">    q.<span class="built_in">len</span> ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">pop</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,<span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> q.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"queue is empty!"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    tmp := q.head</span><br><span class="line">    q.head = tmp.Next</span><br><span class="line">    tmp.Next = <span class="literal">nil</span></span><br><span class="line">    q.<span class="built_in">len</span> --</span><br><span class="line">    <span class="keyword">if</span> q.head == <span class="literal">nil</span> &#123;</span><br><span class="line">        q.tail = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp.T,<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈简要实现"><a href="#栈简要实现" class="headerlink" title="栈简要实现"></a>栈简要实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈的定义，head头设为栈顶，这样处理pop更好处理</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    head *LNode</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span> *<span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Stack&#123;<span class="literal">nil</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">SLen</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">len</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">len</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    s.head = &amp;LNode&#123;val,s.head&#125;</span><br><span class="line">    s.<span class="built_in">len</span> ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,<span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> s.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"stack is empty!"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    tmp := s.head</span><br><span class="line">    s.head = tmp.Next</span><br><span class="line">    tmp.Next = <span class="literal">nil</span></span><br><span class="line">    s.<span class="built_in">len</span> --</span><br><span class="line">    <span class="keyword">return</span> tmp.T,<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Top</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,<span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> s.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"stack is empty!"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.head.T,<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/22/二叉树的遍历（一）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmemory">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Miracle">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/22/二叉树的遍历（一）/" itemprop="url">
                  二叉树的遍历（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-22T10:39:04+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;一个二叉树，要么为空，要么是由一个根节点（N）及其左右两棵子二叉树（L/R）构成。因而，非空二叉树分为三个部分，按照这种递归分析可得到3!=6种遍历方式。我们一般只分析先序（NLR）、中序（LNR）、后序（LRN）三种方式，另外三种实际上是这三种的逆序。</p>
<h2 id="二叉树的生成"><a href="#二叉树的生成" class="headerlink" title="二叉树的生成"></a>二叉树的生成</h2><p>&emsp;&emsp;这段仅仅是为了后面有一个二叉树可用，可自行跳过直接看下一节。<br>&emsp;&emsp;给定一个二叉树的先序序列字符串 AB##CD##EF##G#H## ，构建一个二叉树，其中#为nil（空指针）。可以按照定义去处理，首先构建根结点，再递归的构建左子树和右子树。由于只有一个字符串，我们无法直接知道划分点，但可以肯定的是根字符一定在左子树字符之前，左子树字符一定在右子树字符之前。基于此我们可以在构建树的时候同时返回下一个字符来解决。</p>
<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BTree <span class="keyword">struct</span> &#123;</span><br><span class="line">    root *datastructure.BNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="先序递归构建二叉树"><a href="#先序递归构建二叉树" class="headerlink" title="先序递归构建二叉树"></a>先序递归构建二叉树</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(str <span class="keyword">string</span>, i <span class="keyword">int</span>, <span class="built_in">len</span> <span class="keyword">int</span>)</span> <span class="params">(*datastructure.BNode, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当遍历到字符串结尾或者当前字符为#时，返回</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="built_in">len</span><span class="number">-1</span> || str[i] == <span class="string">'#'</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,i+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    left,index := Create(str,i+<span class="number">1</span>,<span class="built_in">len</span>)  <span class="comment">// 递归构建左子树</span></span><br><span class="line">    right,index := Create(str,index,<span class="built_in">len</span>) <span class="comment">// 递归构建右子树</span></span><br><span class="line">    <span class="keyword">return</span> &amp;datastructure.BNode&#123;T:str[i],Left:left,Right:right&#125;,index <span class="comment">//返回二叉树的根节点及下一个字符index</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBTree</span><span class="params">(str <span class="keyword">string</span>)</span> *<span class="title">BTree</span></span>&#123;</span><br><span class="line">    node,_ := Create(str,<span class="number">0</span>,<span class="built_in">len</span>(str))</span><br><span class="line">    <span class="keyword">return</span> &amp;BTree&#123;node&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><h3 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h3><p>&emsp;&emsp;先序（NLR），即先根、然后左子树、最后右子树。左右子树又是单独的一个二叉树的遍历。按照这种递归的思路，我们很容易写出递归代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PreOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%c"</span>, bt.root.T)</span><br><span class="line">    <span class="comment">// 为了将Node封装成Tree，使得这里显得很蠢</span></span><br><span class="line">    (&amp;BTree&#123;bt.root.Left&#125;).PreOrder()  </span><br><span class="line">    (&amp;BTree&#123;bt.root.Right&#125;).PreOrder()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h3><p>&emsp;&emsp;前面的递归方式实际上借助了一个系统函数调用栈实现的，如果要改为非递归，可以使用显式栈来实现。我们知道二叉树中每个结点有左右两棵子树，当到达某个结点时，如果选择左子树遍历，则后面必定会再一次返回该结点，从而去访问右子树。因此每个结点都需要经过两次。我们可以选择是在第一次或者第二次经过时处理结点，这两种选择分别对应于二叉树遍历的先序和中序方式。</p>
<h4 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h4><p>&emsp;&emsp;每次处理某个结点时，先将右孩子压栈，再将左孩子压栈，这样可以保证当前节点优先于孩子节点处理，左孩子由于右孩子处理。</p>
<pre><code>1. 首先将根节点入栈。
2. 循环只要栈不空，则pop一个节点处理。
3. 该节点右孩子不为空，则入栈。
4. 该几点左孩子不为空，则入栈。
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PreOrder1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    s := datastructure.NewStack()</span><br><span class="line">    s.Push(bt.root)</span><br><span class="line">    p := bt.root</span><br><span class="line">    <span class="keyword">for</span> !s.IsEmpty() &#123;</span><br><span class="line">        t, _ := s.Pop()</span><br><span class="line">        p = t.(*datastructure.BNode)</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>,p.T)</span><br><span class="line">        <span class="keyword">if</span> p.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.Push(p.Right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p.Left != <span class="literal">nil</span>&#123;</span><br><span class="line">            s.Push(p.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面代码是对上面整个循环体内代码的一个优化，减少栈的push pop操作。类似于尾递归的优化。</span></span><br><span class="line">        <span class="comment">// fmt.Printf("%c",p.T)</span></span><br><span class="line">        <span class="comment">// if p.Right != nil &#123;</span></span><br><span class="line">        <span class="comment">//     s.Push(p.Right)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if p.Left != nil&#123;</span></span><br><span class="line">        <span class="comment">//     p = p.Left</span></span><br><span class="line">        <span class="comment">// &#125;else &#123;</span></span><br><span class="line">        <span class="comment">//     t, _ := s.Pop()</span></span><br><span class="line">        <span class="comment">//     p = t.(*datastructure.BNode)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h4><p>&emsp;&emsp;从根节点一直向左按顺序访问并入栈，直到没有左孩子。然后弹出一个节点，访问该节点的右子树（仍然重复前面动作，即从根向左找）。由访问顺序可知，总是先访问了根节点再访问左子树，直到无左子树或已被访问，才转而访问右子树，故符合先序。</p>
<pre><code>1. 从根节点开始，结点非空时处理当前结点并入栈。
2. 当左孩子非空时，一直向左孩子处理并入栈。
3. 当左孩子为空时，弹出结点，处理结点的右子树（即回到1）
4. 循环处理，直到栈为空退出。
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PreOrder2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p := bt.root</span><br><span class="line">    s := datastructure.NewStack()</span><br><span class="line">    <span class="keyword">for</span> p!=<span class="literal">nil</span> || !s.IsEmpty() &#123;</span><br><span class="line">        <span class="comment">// 代码简化：</span></span><br><span class="line">        <span class="comment">// 将根节点的处理合并进了左孩子的情况。</span></span><br><span class="line">        <span class="comment">// 利用if-else和外层的for循环替换掉了内层向左孩子查询的循环。</span></span><br><span class="line">        <span class="keyword">if</span> p!=<span class="literal">nil</span> &#123;</span><br><span class="line">            s.Push(p)</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>,p.T)</span><br><span class="line">            p = p.Left</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t,_ := s.Pop()</span><br><span class="line">            p = t.(*datastructure.BNode).Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归方式-1"><a href="#递归方式-1" class="headerlink" title="递归方式"></a>递归方式</h3><p>&emsp;&emsp;类似于前面先序方式。但中序遍历是先处理左子树，接着处理根节点，最后处理右子树。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">InOrder</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    (&amp;BTree&#123;bt.root.Left&#125;).InOrder()</span><br><span class="line">    fmt.Printf(<span class="string">"%c"</span>,bt.root.T)</span><br><span class="line">    (&amp;BTree&#123;bt.root.Right&#125;).InOrder()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="非递归方式-1"><a href="#非递归方式-1" class="headerlink" title="非递归方式"></a>非递归方式</h3><p>&emsp;&emsp;之前有介绍利用栈遍历时，结点会经过两次，中序遍历是在第二次经过时处理结点，因为此时它的左子树都访问完了，而又准备访问右子树，故符合中序。</p>
<h4 id="思路一：-1"><a href="#思路一：-1" class="headerlink" title="思路一："></a>思路一：</h4><p>&emsp;&emsp;同先序遍历的思路二，只是处理结点由push处改为pop处。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">InOrder1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p := bt.root</span><br><span class="line">    s := datastructure.NewStack()</span><br><span class="line">    <span class="keyword">for</span> p!=<span class="literal">nil</span> || !s.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">if</span> p!=<span class="literal">nil</span> &#123;</span><br><span class="line">            s.Push(p)</span><br><span class="line">            p = p.Left</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t,_ := s.Pop()</span><br><span class="line">            p = t.(*datastructure.BNode)</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>,p.T)</span><br><span class="line">            p = p.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归方式-2"><a href="#递归方式-2" class="headerlink" title="递归方式"></a>递归方式</h3><p>&emsp;&emsp;思想同前。处理时先遍历左子树，接着遍历右子树，最后处理根结点。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PostOrder</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    (&amp;BTree&#123;bt.root.Left&#125;).PostOrder()</span><br><span class="line">    (&amp;BTree&#123;bt.root.Right&#125;).PostOrder()</span><br><span class="line">    fmt.Printf(<span class="string">"%c"</span>,bt.root.T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="非递归方式-2"><a href="#非递归方式-2" class="headerlink" title="非递归方式"></a>非递归方式</h3><p>&emsp;&emsp;由于需要多次经过结点，同样需要借助辅助栈的方式处理。按照在之前分析的，对于某个结点，先序在第一次经过时处理，中序在第二次经过时处理，而后序如果要处理该结点则处理完右边后还要再退回经过该节点处理才行，即需要三次经过该结点。我们知道栈push与pop分别对应两个状态，故处理先序、中序足够了。现在后序需要三种状态，所以要么另外再加一个标识实现第三种状态，要么就转化为先序或中序的思路进行处理，这样就有了两大思路方向了。</p>
<h4 id="思路一：-2"><a href="#思路一：-2" class="headerlink" title="思路一："></a>思路一：</h4><p>&emsp;&emsp;加一个标识达到第三种状态。这样在第一次经过时入栈，第二次经过时暂不做处理，只有当经过该结点且达到相应状态时才处理该结点。可以对每个结点进行一层封装，增加一个标识字段，这样某个结点需要达到状态为孩子为空或孩子均已被访问。也可以只用一个last字段指向上一个处理的字段，当（左右孩子均为空）或（右孩子不为空且last为右孩子）或（右孩子不为空且左孩子不为空且last为左孩子）时达到状态，处理当前节点。显然前者更复杂，且空间开销更大，此处我们选择后一种方法。</p>
<pre><code>1. 由于是后序遍历，首先处理的节点是最左边节点，故先向左扫描并将途中结点入栈。直到向左所有节点都入栈。
2. 只要栈非空，就取栈顶结点，判断该结点是否满足状态。
3. 满足状态，则处理该节点，并弹出。
4. 不满足状态，此时我们一定是第二次经过该结点（第一次是入栈，第三次是满足状态），
由之前中序遍历分析知道，结点左子树已经访问完了，故我们只需要移步到它的右孩子节点，然后重复1步骤就好。
（或者可以在步骤2中直接弹出节点，3中只处理，4中不满足再push进去。但前面的显然更优。）
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PostOrder1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur := bt.root</span><br><span class="line">    last := bt.root</span><br><span class="line">    s := datastructure.NewStack()</span><br><span class="line">    <span class="keyword">for</span> cur!=<span class="literal">nil</span> || !s.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">for</span> cur!=<span class="literal">nil</span>  &#123;</span><br><span class="line">            s.Push(cur)</span><br><span class="line">            cur = cur.Left</span><br><span class="line">        &#125;</span><br><span class="line">        t,_ := s.Top()</span><br><span class="line">        cur = t.(*datastructure.BNode)</span><br><span class="line">        <span class="comment">// (cur.Left==nil&amp;&amp;cur.Right==nil)||(cur.Right!=nil&amp;&amp;last==cur.Right)||(cur.Right==nil&amp;&amp;cur.Left!=nil&amp;&amp;last==cur.Left)</span></span><br><span class="line">        <span class="comment">// 1、当循环开始cur!=nil时，由前面for cur!=nil循环可知，最终栈顶cur的Left必为nil。</span></span><br><span class="line">        <span class="comment">// 所以第一个条件等价于cur.Right==nil ，第三个条件总为false</span></span><br><span class="line">        <span class="comment">// --&gt; cur.Right==nil || (cur.Right!=nil&amp;&amp;last==cur.Right)</span></span><br><span class="line">        <span class="comment">// --&gt; 看成 A || (~A &amp;&amp; B),利用集合公式化简为 (A || ~A)&amp;&amp;(A||B) --&gt; A||B</span></span><br><span class="line">        <span class="comment">// 也可这样分析：当前一个条件为true时 整个为true，当前一个为false时，后一个等价于last==cur.Right</span></span><br><span class="line">        <span class="comment">// --&gt; cur.Right==nil || last==cur.Right</span></span><br><span class="line">        <span class="comment">// 2、当循环开始cur==nil时，需要取栈顶元素作为cur，由之前分析可知左子树访问完了且右边未访问。</span></span><br><span class="line">        <span class="comment">// 显然(cur.Left==nil||(cur.Left!=nil&amp;&amp;last==cur.Left))为true</span></span><br><span class="line">        <span class="comment">// 若cur.Left==nil，分析同1.</span></span><br><span class="line">        <span class="comment">// 若cur.Left!=nil&amp;&amp;last==cur.Left，第一个条件为false，第二个条件也为false，第三个条件等价于cur.Right==nil</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// 综上：最终条件为 cur.Right==nil || last==cur.Right</span></span><br><span class="line">        <span class="comment">// 前面条件表达式实际上有几处是可以利用&amp;&amp;和||的短路特性进行简化的，简化之后再来讨论相应会简单很多。</span></span><br><span class="line">        <span class="keyword">if</span> cur.Right==<span class="literal">nil</span> || last==cur.Right&#123;</span><br><span class="line">            s.Pop()</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>,cur.T)</span><br><span class="line">            last = cur</span><br><span class="line">            cur = <span class="literal">nil</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">Post</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    s := datastructure.NewStack()</span><br><span class="line">    cur := bt.root</span><br><span class="line">    <span class="keyword">var</span> last *datastructure.BNode = <span class="literal">nil</span> </span><br><span class="line">    s.Push(cur)</span><br><span class="line">    <span class="keyword">for</span> !s.IsEmpty()&#123;</span><br><span class="line">        t,_ := s.Top()</span><br><span class="line">        cur = t.(*datastructure.BNode)</span><br><span class="line">        <span class="keyword">if</span> last == <span class="literal">nil</span> || last.Left == cur || last.Right == cur &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.Left!=<span class="literal">nil</span> &#123;</span><br><span class="line">                s.Push(cur.Left)</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> cur.Right!=<span class="literal">nil</span> &#123;</span><br><span class="line">                s.Push(cur.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> cur.Left == last&#123;</span><br><span class="line">            <span class="keyword">if</span> cur.Right!=<span class="literal">nil</span> &#123;</span><br><span class="line">                s.Push(cur.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>,cur.T)</span><br><span class="line">            s.Pop()</span><br><span class="line">        &#125;</span><br><span class="line">        last = cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路二：-1"><a href="#思路二：-1" class="headerlink" title="思路二："></a>思路二：</h4><p>&emsp;&emsp;后序遍历，即先左子树、再右子树、最后处理根结点，LRN方式。我们将之逆转，得到NRL，那么按照NRL方式遍历，得到的序列逆序不就是后序遍历序列么（这里我采用新增一个栈来处理逆序，当然也可以用其他方式）。进一步，需要解决的就是按照NRL方式遍历，细看一下，这不就是先序遍历的翻版么。只需将先序遍历所有left与right指针对调，处理的地方换成压到另一个栈操作即可。</p>
<pre><code>1. 按NRL方式遍历，按处理序列依次入out栈
2. 再依次从out弹出处理
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有适用于先序遍历的实现，同样适用于此思路的后序遍历。</span></span><br><span class="line"><span class="comment">// 这里只取先序遍历思路二的方法来实现后序遍历。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PostOrder2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p := bt.root</span><br><span class="line">    tmpS := datastructure.NewStack()</span><br><span class="line">    outS := datastructure.NewStack()</span><br><span class="line">    <span class="keyword">for</span> p != <span class="literal">nil</span> || !tmpS.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            tmpS.Push(p)</span><br><span class="line">            outS.Push(p)</span><br><span class="line">            p = p.Right</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t,_ := tmpS.Pop()</span><br><span class="line">            p = t.(*datastructure.BNode).Left</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> !outS.IsEmpty() &#123;</span><br><span class="line">        p,_ := outS.Pop()</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>,p.(*datastructure.BNode).T)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/hello-world/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmemory">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Miracle">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/03/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-03T22:37:18+08:00">
                2019-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="cmemory">
          <p class="site-author-name" itemprop="name">cmemory</p>
           
              <p class="site-description motion-element" itemprop="description">改变从每天开始。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cmemory</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
