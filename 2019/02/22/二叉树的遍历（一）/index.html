<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="数据结构,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="&amp;emsp;&amp;emsp;一个二叉树，要么为空，要么是由一个根节点（N）及其左右两棵子二叉树（L/R）构成。因而，非空二叉树分为三个部分，按照这种递归分析可得到3!=6种遍历方式。我们一般只分析先序（NLR）、中序（LNR）、后序（LRN）三种方式，另外三种实际上是这三种的逆序。 二叉树的生成&amp;emsp;&amp;emsp;这段仅仅是为了后面有一个二叉树可用，可自行跳过直接看下一节。&amp;emsp;&amp;emsp;">
<meta name="keywords" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树的遍历（一）">
<meta property="og:url" content="http://yoursite.com/2019/02/22/二叉树的遍历（一）/index.html">
<meta property="og:site_name" content="Miracle">
<meta property="og:description" content="&amp;emsp;&amp;emsp;一个二叉树，要么为空，要么是由一个根节点（N）及其左右两棵子二叉树（L/R）构成。因而，非空二叉树分为三个部分，按照这种递归分析可得到3!=6种遍历方式。我们一般只分析先序（NLR）、中序（LNR）、后序（LRN）三种方式，另外三种实际上是这三种的逆序。 二叉树的生成&amp;emsp;&amp;emsp;这段仅仅是为了后面有一个二叉树可用，可自行跳过直接看下一节。&amp;emsp;&amp;emsp;">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-10-25T07:14:08.532Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="二叉树的遍历（一）">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;一个二叉树，要么为空，要么是由一个根节点（N）及其左右两棵子二叉树（L/R）构成。因而，非空二叉树分为三个部分，按照这种递归分析可得到3!=6种遍历方式。我们一般只分析先序（NLR）、中序（LNR）、后序（LRN）三种方式，另外三种实际上是这三种的逆序。 二叉树的生成&amp;emsp;&amp;emsp;这段仅仅是为了后面有一个二叉树可用，可自行跳过直接看下一节。&amp;emsp;&amp;emsp;">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/02/22/二叉树的遍历（一）/">





  <title> 二叉树的遍历（一） | Miracle </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Miracle</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/22/二叉树的遍历（一）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmemory">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Miracle">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                二叉树的遍历（一）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-22T10:39:04+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&emsp;&emsp;一个二叉树，要么为空，要么是由一个根节点（N）及其左右两棵子二叉树（L/R）构成。因而，非空二叉树分为三个部分，按照这种递归分析可得到3!=6种遍历方式。我们一般只分析先序（NLR）、中序（LNR）、后序（LRN）三种方式，另外三种实际上是这三种的逆序。</p>
<h2 id="二叉树的生成"><a href="#二叉树的生成" class="headerlink" title="二叉树的生成"></a>二叉树的生成</h2><p>&emsp;&emsp;这段仅仅是为了后面有一个二叉树可用，可自行跳过直接看下一节。<br>&emsp;&emsp;给定一个二叉树的先序序列字符串 AB##CD##EF##G#H## ，构建一个二叉树，其中#为nil（空指针）。可以按照定义去处理，首先构建根结点，再递归的构建左子树和右子树。由于只有一个字符串，我们无法直接知道划分点，但可以肯定的是根字符一定在左子树字符之前，左子树字符一定在右子树字符之前。基于此我们可以在构建树的时候同时返回下一个字符来解决。</p>
<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BTree <span class="keyword">struct</span> &#123;</span><br><span class="line">    root *datastructure.BNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="先序递归构建二叉树"><a href="#先序递归构建二叉树" class="headerlink" title="先序递归构建二叉树"></a>先序递归构建二叉树</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(str <span class="keyword">string</span>, i <span class="keyword">int</span>, <span class="built_in">len</span> <span class="keyword">int</span>)</span> <span class="params">(*datastructure.BNode, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当遍历到字符串结尾或者当前字符为#时，返回</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="built_in">len</span><span class="number">-1</span> || str[i] == <span class="string">'#'</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,i+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    left,index := Create(str,i+<span class="number">1</span>,<span class="built_in">len</span>)  <span class="comment">// 递归构建左子树</span></span><br><span class="line">    right,index := Create(str,index,<span class="built_in">len</span>) <span class="comment">// 递归构建右子树</span></span><br><span class="line">    <span class="keyword">return</span> &amp;datastructure.BNode&#123;T:str[i],Left:left,Right:right&#125;,index <span class="comment">//返回二叉树的根节点及下一个字符index</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBTree</span><span class="params">(str <span class="keyword">string</span>)</span> *<span class="title">BTree</span></span>&#123;</span><br><span class="line">    node,_ := Create(str,<span class="number">0</span>,<span class="built_in">len</span>(str))</span><br><span class="line">    <span class="keyword">return</span> &amp;BTree&#123;node&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><h3 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h3><p>&emsp;&emsp;先序（NLR），即先根、然后左子树、最后右子树。左右子树又是单独的一个二叉树的遍历。按照这种递归的思路，我们很容易写出递归代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PreOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%c"</span>, bt.root.T)</span><br><span class="line">    <span class="comment">// 为了将Node封装成Tree，使得这里显得很蠢</span></span><br><span class="line">    (&amp;BTree&#123;bt.root.Left&#125;).PreOrder()  </span><br><span class="line">    (&amp;BTree&#123;bt.root.Right&#125;).PreOrder()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h3><p>&emsp;&emsp;前面的递归方式实际上借助了一个系统函数调用栈实现的，如果要改为非递归，可以使用显式栈来实现。我们知道二叉树中每个结点有左右两棵子树，当到达某个结点时，如果选择左子树遍历，则后面必定会再一次返回该结点，从而去访问右子树。因此每个结点都需要经过两次。我们可以选择是在第一次或者第二次经过时处理结点，这两种选择分别对应于二叉树遍历的先序和中序方式。</p>
<h4 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h4><p>&emsp;&emsp;每次处理某个结点时，先将右孩子压栈，再将左孩子压栈，这样可以保证当前节点优先于孩子节点处理，左孩子由于右孩子处理。</p>
<pre><code>1. 首先将根节点入栈。
2. 循环只要栈不空，则pop一个节点处理。
3. 该节点右孩子不为空，则入栈。
4. 该几点左孩子不为空，则入栈。
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PreOrder1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    s := datastructure.NewStack()</span><br><span class="line">    s.Push(bt.root)</span><br><span class="line">    p := bt.root</span><br><span class="line">    <span class="keyword">for</span> !s.IsEmpty() &#123;</span><br><span class="line">        t, _ := s.Pop()</span><br><span class="line">        p = t.(*datastructure.BNode)</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>,p.T)</span><br><span class="line">        <span class="keyword">if</span> p.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.Push(p.Right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p.Left != <span class="literal">nil</span>&#123;</span><br><span class="line">            s.Push(p.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面代码是对上面整个循环体内代码的一个优化，减少栈的push pop操作。类似于尾递归的优化。</span></span><br><span class="line">        <span class="comment">// fmt.Printf("%c",p.T)</span></span><br><span class="line">        <span class="comment">// if p.Right != nil &#123;</span></span><br><span class="line">        <span class="comment">//     s.Push(p.Right)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if p.Left != nil&#123;</span></span><br><span class="line">        <span class="comment">//     p = p.Left</span></span><br><span class="line">        <span class="comment">// &#125;else &#123;</span></span><br><span class="line">        <span class="comment">//     t, _ := s.Pop()</span></span><br><span class="line">        <span class="comment">//     p = t.(*datastructure.BNode)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h4><p>&emsp;&emsp;从根节点一直向左按顺序访问并入栈，直到没有左孩子。然后弹出一个节点，访问该节点的右子树（仍然重复前面动作，即从根向左找）。由访问顺序可知，总是先访问了根节点再访问左子树，直到无左子树或已被访问，才转而访问右子树，故符合先序。</p>
<pre><code>1. 从根节点开始，结点非空时处理当前结点并入栈。
2. 当左孩子非空时，一直向左孩子处理并入栈。
3. 当左孩子为空时，弹出结点，处理结点的右子树（即回到1）
4. 循环处理，直到栈为空退出。
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PreOrder2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p := bt.root</span><br><span class="line">    s := datastructure.NewStack()</span><br><span class="line">    <span class="keyword">for</span> p!=<span class="literal">nil</span> || !s.IsEmpty() &#123;</span><br><span class="line">        <span class="comment">// 代码简化：</span></span><br><span class="line">        <span class="comment">// 将根节点的处理合并进了左孩子的情况。</span></span><br><span class="line">        <span class="comment">// 利用if-else和外层的for循环替换掉了内层向左孩子查询的循环。</span></span><br><span class="line">        <span class="keyword">if</span> p!=<span class="literal">nil</span> &#123;</span><br><span class="line">            s.Push(p)</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>,p.T)</span><br><span class="line">            p = p.Left</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t,_ := s.Pop()</span><br><span class="line">            p = t.(*datastructure.BNode).Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归方式-1"><a href="#递归方式-1" class="headerlink" title="递归方式"></a>递归方式</h3><p>&emsp;&emsp;类似于前面先序方式。但中序遍历是先处理左子树，接着处理根节点，最后处理右子树。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">InOrder</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    (&amp;BTree&#123;bt.root.Left&#125;).InOrder()</span><br><span class="line">    fmt.Printf(<span class="string">"%c"</span>,bt.root.T)</span><br><span class="line">    (&amp;BTree&#123;bt.root.Right&#125;).InOrder()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="非递归方式-1"><a href="#非递归方式-1" class="headerlink" title="非递归方式"></a>非递归方式</h3><p>&emsp;&emsp;之前有介绍利用栈遍历时，结点会经过两次，中序遍历是在第二次经过时处理结点，因为此时它的左子树都访问完了，而又准备访问右子树，故符合中序。</p>
<h4 id="思路一：-1"><a href="#思路一：-1" class="headerlink" title="思路一："></a>思路一：</h4><p>&emsp;&emsp;同先序遍历的思路二，只是处理结点由push处改为pop处。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">InOrder1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p := bt.root</span><br><span class="line">    s := datastructure.NewStack()</span><br><span class="line">    <span class="keyword">for</span> p!=<span class="literal">nil</span> || !s.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">if</span> p!=<span class="literal">nil</span> &#123;</span><br><span class="line">            s.Push(p)</span><br><span class="line">            p = p.Left</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t,_ := s.Pop()</span><br><span class="line">            p = t.(*datastructure.BNode)</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>,p.T)</span><br><span class="line">            p = p.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归方式-2"><a href="#递归方式-2" class="headerlink" title="递归方式"></a>递归方式</h3><p>&emsp;&emsp;思想同前。处理时先遍历左子树，接着遍历右子树，最后处理根结点。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PostOrder</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    (&amp;BTree&#123;bt.root.Left&#125;).PostOrder()</span><br><span class="line">    (&amp;BTree&#123;bt.root.Right&#125;).PostOrder()</span><br><span class="line">    fmt.Printf(<span class="string">"%c"</span>,bt.root.T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="非递归方式-2"><a href="#非递归方式-2" class="headerlink" title="非递归方式"></a>非递归方式</h3><p>&emsp;&emsp;由于需要多次经过结点，同样需要借助辅助栈的方式处理。按照在之前分析的，对于某个结点，先序在第一次经过时处理，中序在第二次经过时处理，而后序如果要处理该结点则处理完右边后还要再退回经过该节点处理才行，即需要三次经过该结点。我们知道栈push与pop分别对应两个状态，故处理先序、中序足够了。现在后序需要三种状态，所以要么另外再加一个标识实现第三种状态，要么就转化为先序或中序的思路进行处理，这样就有了两大思路方向了。</p>
<h4 id="思路一：-2"><a href="#思路一：-2" class="headerlink" title="思路一："></a>思路一：</h4><p>&emsp;&emsp;加一个标识达到第三种状态。这样在第一次经过时入栈，第二次经过时暂不做处理，只有当经过该结点且达到相应状态时才处理该结点。可以对每个结点进行一层封装，增加一个标识字段，这样某个结点需要达到状态为孩子为空或孩子均已被访问。也可以只用一个last字段指向上一个处理的字段，当（左右孩子均为空）或（右孩子不为空且last为右孩子）或（右孩子不为空且左孩子不为空且last为左孩子）时达到状态，处理当前节点。显然前者更复杂，且空间开销更大，此处我们选择后一种方法。</p>
<pre><code>1. 由于是后序遍历，首先处理的节点是最左边节点，故先向左扫描并将途中结点入栈。直到向左所有节点都入栈。
2. 只要栈非空，就取栈顶结点，判断该结点是否满足状态。
3. 满足状态，则处理该节点，并弹出。
4. 不满足状态，此时我们一定是第二次经过该结点（第一次是入栈，第三次是满足状态），
由之前中序遍历分析知道，结点左子树已经访问完了，故我们只需要移步到它的右孩子节点，然后重复1步骤就好。
（或者可以在步骤2中直接弹出节点，3中只处理，4中不满足再push进去。但前面的显然更优。）
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PostOrder1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur := bt.root</span><br><span class="line">    last := bt.root</span><br><span class="line">    s := datastructure.NewStack()</span><br><span class="line">    <span class="keyword">for</span> cur!=<span class="literal">nil</span> || !s.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">for</span> cur!=<span class="literal">nil</span>  &#123;</span><br><span class="line">            s.Push(cur)</span><br><span class="line">            cur = cur.Left</span><br><span class="line">        &#125;</span><br><span class="line">        t,_ := s.Top()</span><br><span class="line">        cur = t.(*datastructure.BNode)</span><br><span class="line">        <span class="comment">// (cur.Left==nil&amp;&amp;cur.Right==nil)||(cur.Right!=nil&amp;&amp;last==cur.Right)||(cur.Right==nil&amp;&amp;cur.Left!=nil&amp;&amp;last==cur.Left)</span></span><br><span class="line">        <span class="comment">// 1、当循环开始cur!=nil时，由前面for cur!=nil循环可知，最终栈顶cur的Left必为nil。</span></span><br><span class="line">        <span class="comment">// 所以第一个条件等价于cur.Right==nil ，第三个条件总为false</span></span><br><span class="line">        <span class="comment">// --&gt; cur.Right==nil || (cur.Right!=nil&amp;&amp;last==cur.Right)</span></span><br><span class="line">        <span class="comment">// --&gt; 看成 A || (~A &amp;&amp; B),利用集合公式化简为 (A || ~A)&amp;&amp;(A||B) --&gt; A||B</span></span><br><span class="line">        <span class="comment">// 也可这样分析：当前一个条件为true时 整个为true，当前一个为false时，后一个等价于last==cur.Right</span></span><br><span class="line">        <span class="comment">// --&gt; cur.Right==nil || last==cur.Right</span></span><br><span class="line">        <span class="comment">// 2、当循环开始cur==nil时，需要取栈顶元素作为cur，由之前分析可知左子树访问完了且右边未访问。</span></span><br><span class="line">        <span class="comment">// 显然(cur.Left==nil||(cur.Left!=nil&amp;&amp;last==cur.Left))为true</span></span><br><span class="line">        <span class="comment">// 若cur.Left==nil，分析同1.</span></span><br><span class="line">        <span class="comment">// 若cur.Left!=nil&amp;&amp;last==cur.Left，第一个条件为false，第二个条件也为false，第三个条件等价于cur.Right==nil</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// 综上：最终条件为 cur.Right==nil || last==cur.Right</span></span><br><span class="line">        <span class="comment">// 前面条件表达式实际上有几处是可以利用&amp;&amp;和||的短路特性进行简化的，简化之后再来讨论相应会简单很多。</span></span><br><span class="line">        <span class="keyword">if</span> cur.Right==<span class="literal">nil</span> || last==cur.Right&#123;</span><br><span class="line">            s.Pop()</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>,cur.T)</span><br><span class="line">            last = cur</span><br><span class="line">            cur = <span class="literal">nil</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">Post</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    s := datastructure.NewStack()</span><br><span class="line">    cur := bt.root</span><br><span class="line">    <span class="keyword">var</span> last *datastructure.BNode = <span class="literal">nil</span> </span><br><span class="line">    s.Push(cur)</span><br><span class="line">    <span class="keyword">for</span> !s.IsEmpty()&#123;</span><br><span class="line">        t,_ := s.Top()</span><br><span class="line">        cur = t.(*datastructure.BNode)</span><br><span class="line">        <span class="keyword">if</span> last == <span class="literal">nil</span> || last.Left == cur || last.Right == cur &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.Left!=<span class="literal">nil</span> &#123;</span><br><span class="line">                s.Push(cur.Left)</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> cur.Right!=<span class="literal">nil</span> &#123;</span><br><span class="line">                s.Push(cur.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> cur.Left == last&#123;</span><br><span class="line">            <span class="keyword">if</span> cur.Right!=<span class="literal">nil</span> &#123;</span><br><span class="line">                s.Push(cur.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>,cur.T)</span><br><span class="line">            s.Pop()</span><br><span class="line">        &#125;</span><br><span class="line">        last = cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路二：-1"><a href="#思路二：-1" class="headerlink" title="思路二："></a>思路二：</h4><p>&emsp;&emsp;后序遍历，即先左子树、再右子树、最后处理根结点，LRN方式。我们将之逆转，得到NRL，那么按照NRL方式遍历，得到的序列逆序不就是后序遍历序列么（这里我采用新增一个栈来处理逆序，当然也可以用其他方式）。进一步，需要解决的就是按照NRL方式遍历，细看一下，这不就是先序遍历的翻版么。只需将先序遍历所有left与right指针对调，处理的地方换成压到另一个栈操作即可。</p>
<pre><code>1. 按NRL方式遍历，按处理序列依次入out栈
2. 再依次从out弹出处理
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有适用于先序遍历的实现，同样适用于此思路的后序遍历。</span></span><br><span class="line"><span class="comment">// 这里只取先序遍历思路二的方法来实现后序遍历。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BTree)</span> <span class="title">PostOrder2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> bt.root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p := bt.root</span><br><span class="line">    tmpS := datastructure.NewStack()</span><br><span class="line">    outS := datastructure.NewStack()</span><br><span class="line">    <span class="keyword">for</span> p != <span class="literal">nil</span> || !tmpS.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            tmpS.Push(p)</span><br><span class="line">            outS.Push(p)</span><br><span class="line">            p = p.Right</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t,_ := tmpS.Pop()</span><br><span class="line">            p = t.(*datastructure.BNode).Left</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> !outS.IsEmpty() &#123;</span><br><span class="line">        p,_ := outS.Pop()</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>,p.(*datastructure.BNode).T)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/03/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/22/基本数据结构/" rel="prev" title="基本数据结构">
                基本数据结构 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="cmemory">
          <p class="site-author-name" itemprop="name">cmemory</p>
           
              <p class="site-description motion-element" itemprop="description">改变从每天开始。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的生成"><span class="nav-number">1.</span> <span class="nav-text">二叉树的生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的定义"><span class="nav-number">1.1.</span> <span class="nav-text">二叉树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#先序递归构建二叉树"><span class="nav-number">1.2.</span> <span class="nav-text">先序递归构建二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#先序遍历"><span class="nav-number">2.</span> <span class="nav-text">先序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归方式"><span class="nav-number">2.1.</span> <span class="nav-text">递归方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非递归方式"><span class="nav-number">2.2.</span> <span class="nav-text">非递归方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#思路一："><span class="nav-number">2.2.1.</span> <span class="nav-text">思路一：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路二："><span class="nav-number">2.2.2.</span> <span class="nav-text">思路二：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中序遍历"><span class="nav-number">3.</span> <span class="nav-text">中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归方式-1"><span class="nav-number">3.1.</span> <span class="nav-text">递归方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非递归方式-1"><span class="nav-number">3.2.</span> <span class="nav-text">非递归方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#思路一：-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">思路一：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后序遍历"><span class="nav-number">4.</span> <span class="nav-text">后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归方式-2"><span class="nav-number">4.1.</span> <span class="nav-text">递归方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非递归方式-2"><span class="nav-number">4.2.</span> <span class="nav-text">非递归方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#思路一：-2"><span class="nav-number">4.2.1.</span> <span class="nav-text">思路一：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路二：-1"><span class="nav-number">4.2.2.</span> <span class="nav-text">思路二：</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cmemory</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
