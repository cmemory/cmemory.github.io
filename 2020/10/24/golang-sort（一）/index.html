<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="golang,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="排序整体介绍golang提供了sort接口，我们可以只要实现该接口就可以调用内置的Sort函数进行排序。 12345678910111213// 集合类型需要实现该接口才能直接使用Sort函数type Interface interface &amp;#123;	Len() int	// 集合长度	Less(i, j int) bool	// 集合中i位置的元素是否应该排在j位置元素的前面	Swap(i,">
<meta name="keywords" content="golang">
<meta property="og:type" content="article">
<meta property="og:title" content="golang-sort">
<meta property="og:url" content="http://yoursite.com/2020/10/24/golang-sort（一）/index.html">
<meta property="og:site_name" content="Miracle">
<meta property="og:description" content="排序整体介绍golang提供了sort接口，我们可以只要实现该接口就可以调用内置的Sort函数进行排序。 12345678910111213// 集合类型需要实现该接口才能直接使用Sort函数type Interface interface &amp;#123;	Len() int	// 集合长度	Less(i, j int) bool	// 集合中i位置的元素是否应该排在j位置元素的前面	Swap(i,">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-10-25T07:42:51.168Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="golang-sort">
<meta name="twitter:description" content="排序整体介绍golang提供了sort接口，我们可以只要实现该接口就可以调用内置的Sort函数进行排序。 12345678910111213// 集合类型需要实现该接口才能直接使用Sort函数type Interface interface &amp;#123;	Len() int	// 集合长度	Less(i, j int) bool	// 集合中i位置的元素是否应该排在j位置元素的前面	Swap(i,">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/10/24/golang-sort（一）/">





  <title> golang-sort | Miracle </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Miracle</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/24/golang-sort（一）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmemory">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Miracle">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                golang-sort
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-24T15:57:59+08:00">
                2020-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="排序整体介绍"><a href="#排序整体介绍" class="headerlink" title="排序整体介绍"></a>排序整体介绍</h3><p>golang提供了sort接口，我们可以只要实现该接口就可以调用内置的Sort函数进行排序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合类型需要实现该接口才能直接使用Sort函数</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Len() <span class="keyword">int</span>	<span class="comment">// 集合长度</span></span><br><span class="line">	Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span>	<span class="comment">// 集合中i位置的元素是否应该排在j位置元素的前面</span></span><br><span class="line">	Swap(i, j <span class="keyword">int</span>)	<span class="comment">// 交换集合i和j位置的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort函数，直接调用的quickSort进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> &#123;</span><br><span class="line">	n := data.Len()</span><br><span class="line">    <span class="comment">// maxDepth 快排递归的深度，每次递归都会减1，当减为0时采用堆排序。</span></span><br><span class="line">	quickSort(data, <span class="number">0</span>, n, maxDepth(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>golang整个Sort的实现使用了快速排序、堆排序、希尔排序、插入排序。</p>
<p>1、整体流程上使用的是递归的快速排序。（元素大于12时）<br>2、初始时会根据集合元素的个数计算一个max_depth，为递归的最大深度。<br>3、每次递归的时候max_depth会减一，当递归到该值为0时，采用堆排序。<br>4、当元素&lt;=12时，排序采用步长为6的希尔排序。这里只需要一遍希尔就可以了。<br>5、对于希尔排序结果，采用插入排序完成最终排序。</p>
<h3 id="排序代码流程"><a href="#排序代码流程" class="headerlink" title="排序代码流程"></a>排序代码流程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于长度为n的集合，max_depth为2*ceil(lg(n+1))，lg(n+1)向上取整的两倍。</span></span><br><span class="line"><span class="comment">// 快排复杂度为O(lgn)，这里是给出最大递归深度max_depth，超过后要切换为堆排序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> depth <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := n; i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span> &#123;</span><br><span class="line">		depth++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> depth * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort中调用的此函数进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(data Interface, a, b, maxDepth <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> b-a &gt; <span class="number">12</span> &#123;</span><br><span class="line">        <span class="comment">// maxDepth 降为0时采用堆排序</span></span><br><span class="line">		<span class="keyword">if</span> maxDepth == <span class="number">0</span> &#123;</span><br><span class="line">			heapSort(data, a, b)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		maxDepth--</span><br><span class="line">        <span class="comment">// doPivot寻找合适的切分元素pivot，将集合数据划分为3部分，并返回两个切分点mlo, mhi。</span></span><br><span class="line">        <span class="comment">// [a,mlo)的元素都小于pivot</span></span><br><span class="line">        <span class="comment">// [mhi,b)的元素都大于pivot</span></span><br><span class="line">        <span class="comment">// [mlo,mhi)之间的元素都等于pivot</span></span><br><span class="line">		mlo, mhi := doPivot(data, a, b)</span><br><span class="line">        <span class="comment">// 对于元素少的那一部分进行递归调用。元素多的部分使用尾递归。减少递归栈内存使用。</span></span><br><span class="line">		<span class="keyword">if</span> mlo-a &lt; b-mhi &#123;</span><br><span class="line">			quickSort(data, a, mlo, maxDepth)</span><br><span class="line">			a = mhi <span class="comment">// 尾递归优化，等价于quickSort(data, mhi, b, maxDepth)</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			quickSort(data, mhi, b, maxDepth)</span><br><span class="line">			b = mlo <span class="comment">// 等价于quickSort(data, a, mlo, maxDepth)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归过程中元素个数不超过12时，采用一次希尔排序加一次插入排序</span></span><br><span class="line">	<span class="keyword">if</span> b-a &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 元素不超过12，所以步长为6，每次只需要比对两个元素。</span></span><br><span class="line">		<span class="keyword">for</span> i := a + <span class="number">6</span>; i &lt; b; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> data.Less(i, i<span class="number">-6</span>) &#123;</span><br><span class="line">				data.Swap(i, i<span class="number">-6</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 插入排序，使得最终集合有序</span></span><br><span class="line">		insertionSort(data, a, b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入和希尔排序这里很清楚了，就不另外解释了。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(data Interface, a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := a + <span class="number">1</span>; i &lt; b; i++ &#123;</span><br><span class="line">        <span class="comment">// 对于所选择的元素i，依次向前对比，如果i更小，则交换。</span></span><br><span class="line">		<span class="keyword">for</span> j := i; j &gt; a &amp;&amp; data.Less(j, j<span class="number">-1</span>); j-- &#123;</span><br><span class="line">			data.Swap(j, j<span class="number">-1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>Sort中快速排序思路就是两步：<br>1、划分。选取一个基准元素，将集合划分为&lt;，=，&gt;基准元素的三个新集合。<br>2、递归。将得到的三个新的集合递归进行处理。</p>
<p>可以看到，真正处理部分是在划分，而划分的难点实际上在于每次基准元素的选择。<br>如果基准元素选择的不好，极端情况快排退化成了插入排序，如每次都选取到最小元素的情况。<br>理论上最优的基准元素是中位数，大于和小于基准元素的个数基本相等。</p>
<p>Sort中快排基准点选择使用的是基于采样的<a href="https://www.johndcook.com/blog/2009/06/23/tukey-median-ninther/" target="_blank" rel="noopener">median of three medians of three</a>方式。<br>1、对于集合开始、中间、末尾分别采样3个元素。<br>2、分别求采样的三个部分各自中位数，得到3个数。<br>3、求这3个数的中位数，即作为基准元素进行一次的划分。</p>
<p>从上面我们可以知道，对于选择的基准点p，集合中至少有3+1个元素&gt;=p，且至少有3+1个元素&lt;=p。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序3个元素使得data[m0] &lt;= data[m1] &lt;= data[m2]，从而我们知道m1处的元素即为中位数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">medianOfThree</span><span class="params">(data Interface, m1, m0, m2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> data.Less(m1, m0) &#123;</span><br><span class="line">		data.Swap(m1, m0)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> data.Less(m2, m1) &#123;</span><br><span class="line">		data.Swap(m2, m1)</span><br><span class="line">		<span class="keyword">if</span> data.Less(m1, m0) &#123;</span><br><span class="line">			data.Swap(m1, m0)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doPivot</span><span class="params">(data Interface, lo, hi <span class="keyword">int</span>)</span> <span class="params">(midlo, midhi <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">int</span>(<span class="keyword">uint</span>(lo+hi) &gt;&gt; <span class="number">1</span>)	<span class="comment">// 避免int溢出</span></span><br><span class="line">	<span class="keyword">if</span> hi-lo &gt; <span class="number">40</span> &#123;</span><br><span class="line">		s := (hi - lo) / <span class="number">8</span>	<span class="comment">// 选择采样步长</span></span><br><span class="line">        <span class="comment">// 在头、中、尾分别采样，计算相应的中位数放置在lo、m、hi-1位置</span></span><br><span class="line">		medianOfThree(data, lo, lo+s, lo+<span class="number">2</span>*s)</span><br><span class="line">		medianOfThree(data, m, m-s, m+s)</span><br><span class="line">		medianOfThree(data, hi<span class="number">-1</span>, hi<span class="number">-1</span>-s, hi<span class="number">-1</span><span class="number">-2</span>*s)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 取lo、m、hi-1位置的数，计算中位数放在首位</span></span><br><span class="line">	medianOfThree(data, lo, m, hi<span class="number">-1</span>)</span><br><span class="line">    -----------------------------------------------------------------</span><br><span class="line">	<span class="comment">// 不变式:</span></span><br><span class="line">	<span class="comment">// 1、data[lo] = pivot (选择的基准)</span></span><br><span class="line">	<span class="comment">// 2、data[lo &lt; i &lt; a] &lt; pivot (由下面第一个for循环保证)</span></span><br><span class="line">	<span class="comment">// 3、data[a &lt;= i &lt; b] &lt;= pivot </span></span><br><span class="line">	<span class="comment">// 4、data[b &lt;= i &lt; c] unexamined</span></span><br><span class="line">	<span class="comment">// 5、data[c &lt;= i &lt; hi-1] &gt; pivot</span></span><br><span class="line">	<span class="comment">// 6、data[hi-1] &gt;= pivot (有前面中位数选择保证)</span></span><br><span class="line">	pivot := lo</span><br><span class="line">	a, c := lo+<span class="number">1</span>, hi<span class="number">-1</span></span><br><span class="line">	<span class="comment">// 不变式的2由这个循环保证</span></span><br><span class="line">	<span class="keyword">for</span> ; a &lt; c &amp;&amp; data.Less(a, pivot); a++ &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	b := a</span><br><span class="line">    <span class="comment">// 不变式的3、4、5由这个循环保证，将剩下元素划分为&lt;=和&gt;两个部分。</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> ; b &lt; c &amp;&amp; !data.Less(pivot, b); b++ &#123; <span class="comment">// data[b] &lt;= pivot</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ; b &lt; c &amp;&amp; data.Less(pivot, c<span class="number">-1</span>); c-- &#123; <span class="comment">// data[c-1] &gt; pivot</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> b &gt;= c &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// data[b] &gt; pivot; data[c-1] &lt;= pivot</span></span><br><span class="line">        <span class="comment">// 交换并缩减比较范围</span></span><br><span class="line">		data.Swap(b, c<span class="number">-1</span>)</span><br><span class="line">		b++</span><br><span class="line">		c--</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 经过前面的操作，得到如下划分：(这里应该有b==c)</span></span><br><span class="line">    <span class="comment">// 1、data[lo] = pivot</span></span><br><span class="line">    <span class="comment">// 2、data[lo &lt; i &lt; a] &lt; pivot</span></span><br><span class="line">    <span class="comment">// 3、data[a &lt;= i &lt; b] &lt;= pivot </span></span><br><span class="line">    <span class="comment">// 4、data[c &lt;= i &lt; hi-1] &gt; pivot</span></span><br><span class="line">    <span class="comment">// 5、data[hi-1] &gt;= pivot (有前面中位数选择保证)</span></span><br><span class="line">    <span class="comment">// 后面要做的是尽可能将与基准相等的元素放在[b,c)，保证尽可能少的元素再参与递归处理。</span></span><br><span class="line">    <span class="comment">// 事实上，相同的元素不做处理也是可以的，只是如果相同元素过多会影响性能。</span></span><br><span class="line">    ----------------------------------------------------------------</span><br><span class="line">    <span class="comment">// 前面说过，集合中至少有4个元素&gt;=基准，不算基准有3个&gt;=基准</span></span><br><span class="line">    <span class="comment">// 所以当hi-c &lt; 3的时候，集合中前面一定有等于基准的元素。</span></span><br><span class="line">    <span class="comment">// 这里比较保守，边界设置的5。小于5就认为需要检查。</span></span><br><span class="line">	protect := hi-c &lt; <span class="number">5</span></span><br><span class="line">	<span class="keyword">if</span> !protect &amp;&amp; hi-c &lt; (hi-lo)/<span class="number">4</span> &#123;</span><br><span class="line">        <span class="comment">// 当[c, hi)的元素个数&gt;=5且&lt;总元素个数的1/4时</span></span><br><span class="line">        <span class="comment">// 选取一些点测试是否与基准相等</span></span><br><span class="line">		dups := <span class="number">0</span></span><br><span class="line">        <span class="comment">// 检测hi-1处元素，因为没有equals函数，所以只能这样检查。</span></span><br><span class="line">		<span class="keyword">if</span> !data.Less(pivot, hi<span class="number">-1</span>) &#123; <span class="comment">// data[hi-1] &lt;= pivot</span></span><br><span class="line">			data.Swap(c, hi<span class="number">-1</span>)</span><br><span class="line">			c++</span><br><span class="line">			dups++</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 检测b-1处元素是否与基准相等，如果相等则b==c-1，不等则b==c</span></span><br><span class="line">		<span class="keyword">if</span> !data.Less(b<span class="number">-1</span>, pivot) &#123; <span class="comment">// data[b-1] &gt;= pivot</span></span><br><span class="line">			b--</span><br><span class="line">			dups++</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// m-lo = (hi-lo)/2</span></span><br><span class="line">        <span class="comment">// 由if条件可知：hi-c &lt; (hi-lo)/4 ==&gt; c-lo&gt;(hi-lo)3/4</span></span><br><span class="line">        <span class="comment">// 又因为b&lt;=c，事实上b==c或者b==c-1，则b-lo&gt;(hi-lo)3/4-1</span></span><br><span class="line">        <span class="comment">// ==&gt; b-lo &gt; m-lo</span></span><br><span class="line">		<span class="comment">// ==&gt; m &lt; b ==&gt; data[m] &lt;= pivot</span></span><br><span class="line">		<span class="keyword">if</span> !data.Less(m, pivot) &#123; <span class="comment">// data[m] = pivot</span></span><br><span class="line">			data.Swap(m, b<span class="number">-1</span>)</span><br><span class="line">			b--</span><br><span class="line">			dups++</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果三个检测点中至少有两个点都与基准相等，则假定偏态分布</span></span><br><span class="line">        <span class="comment">// 前面可能还有很多与基准相等的点，需要进行遍历检测处理。</span></span><br><span class="line">		protect = dups &gt; <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> protect &#123;</span><br><span class="line">        <span class="comment">// 检查与基准相同元素，根据我们前面划分，只需要判断[a,b)的元素就可以了。</span></span><br><span class="line">        <span class="comment">// 处理过程跟前面划分集合为&lt;=和&gt;两部分类似。</span></span><br><span class="line">		<span class="comment">// 循环不变式:</span></span><br><span class="line">		<span class="comment">//	data[a &lt;= i &lt; b] 待检测</span></span><br><span class="line">		<span class="comment">//	data[b &lt;= i &lt; c] = pivot</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 循环，遇到与基准相等的，b--，继续检查</span></span><br><span class="line">			<span class="keyword">for</span> ; a &lt; b &amp;&amp; !data.Less(b<span class="number">-1</span>, pivot); b-- &#123; <span class="comment">// data[b] == pivot</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> ; a &lt; b &amp;&amp; data.Less(a, pivot); a++ &#123; <span class="comment">// data[a] &lt; pivot</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// data[a] == pivot; data[b-1] &lt; pivot</span></span><br><span class="line">			data.Swap(a, b<span class="number">-1</span>)</span><br><span class="line">			a++</span><br><span class="line">			b--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 将基准放到合适的位置，最终[lo, b-1)都小于基准。[c，hi)都大于基准。</span></span><br><span class="line">	data.Swap(pivot, b<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> b - <span class="number">1</span>, c</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>构建堆的方式主要有两种：<br>1、sift_down，从上往下调整堆。已有的堆作为子树，向根加节点，调整使得新树成为堆。<br>2、sift_up，从下往上调整堆。已有堆，向树的最后的叶子后面加节点，调整新树成为堆。</p>
<p>如果修改堆中的某个元素，则需要判断值是变大还是变小，从而选择down或up方式来调整堆。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(data Interface, a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	first := a</span><br><span class="line">	lo := <span class="number">0</span></span><br><span class="line">	hi := b - a</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建大根堆，需要依次遍历节点，调整以节点为根的树成为大根堆。</span></span><br><span class="line">    <span class="comment">// 由于调整当前节点时，必须保证子树都已经是大根堆，所以这里从后往前遍历。</span></span><br><span class="line">    <span class="comment">// 显然叶子节点只有单个节点，就是一个大根堆，不需要处理。</span></span><br><span class="line">	<span class="keyword">for</span> i := (hi - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		siftDown(data, i, hi, first)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次取最大（堆顶）元素与堆末尾元素交换。然后调整堆使重新成为大根堆。</span></span><br><span class="line">    <span class="comment">// 每次操作，堆中元素会少一个，而有序的元素会加一。</span></span><br><span class="line">    <span class="comment">// 最终会形成一个从小到大排好序的序列。</span></span><br><span class="line">	<span class="keyword">for</span> i := hi - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		data.Swap(first, first+i)</span><br><span class="line">		siftDown(data, lo, i, first)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// siftDown，节点lo依次向下比较，使得以lo为根的树是一个大根堆。</span></span><br><span class="line"><span class="comment">// 注意调整lo为根的树时，必须保证lo的子树都已经是大根堆。</span></span><br><span class="line"><span class="comment">// 这里由于集合元素是[0, hi)，所以判断是否有子节点使用2*root+1&gt;=hi。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown</span><span class="params">(data Interface, lo, hi, first <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	root := lo</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		child := <span class="number">2</span>*root + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 判断是否有子节点，没有则直接跳出循环返回。</span></span><br><span class="line">		<span class="keyword">if</span> child &gt;= hi &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 先比较两个孩子节点，child最终指向大的那个孩子。</span></span><br><span class="line">        <span class="comment">// 默认child是指向左孩子的，如果没有右孩子，child仍然是指向大的那个孩子。</span></span><br><span class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; hi &amp;&amp; data.Less(first+child, first+child+<span class="number">1</span>) &#123;</span><br><span class="line">			child++</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 对比较大的孩子与当前节点，如果当前节点大，则不用变动就是大根，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> !data.Less(first+root, first+child) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 孩子节点大于当前节点，则需要交换。</span></span><br><span class="line">        <span class="comment">// 交换后破坏了所交换孩子的那颗子树，需要重新调整为大根堆。</span></span><br><span class="line">		data.Swap(first+root, first+child)</span><br><span class="line">		root = child</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/golang/" rel="tag"># golang</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/22/基本数据结构/" rel="next" title="基本数据结构">
                <i class="fa fa-chevron-left"></i> 基本数据结构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/10/25/golang-sort（二）/" rel="prev" title="golang-sort（二）">
                golang-sort（二） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="cmemory">
          <p class="site-author-name" itemprop="name">cmemory</p>
           
              <p class="site-description motion-element" itemprop="description">改变从每天开始。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序整体介绍"><span class="nav-number">1.</span> <span class="nav-text">排序整体介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序代码流程"><span class="nav-number">2.</span> <span class="nav-text">排序代码流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-number">3.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序"><span class="nav-number">4.</span> <span class="nav-text">堆排序</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cmemory</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
